# Backend Canonical Data Model

This document consolidates the backend payloads required by the Portfolio Performance Reader frontend. Each field listed below matches the harmonised push event shapes so the UI can render without synthesising fallback data or duplicating calculations. The `pp_reader/get_dashboard_data` websocket call continues to provide the overview snapshot on initial load; that handler still returns its legacy field set (for example `has_current_value` on portfolio entries) while the push payloads described here remain the canonical source of truth for live updates.

**Recommendation:** The six backend data source options below cover the full set of frontend needs; no additional sourcing categories are required.

## Dashboard snapshot (`pp_reader/get_dashboard_data` command; push updates: `accounts`, `portfolio_values`, `portfolio_positions`, `last_file_update`)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `accounts[]` | array of account objects | Overview liquidity tables | Mirrors the `accounts` push payload (see below) so the frontend can render the EUR and FX tables before live events arrive. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_load_accounts_payload` prepares the same dictionaries used for push events; the websocket handler forwards them unchanged, including the optional `fx_unavailable` flag.【F:custom_components/pp_reader/data/websocket.py†L60-L134】 |
| `portfolios[]` | array of portfolio summary objects | Portfolio overview table | Mirrors the `portfolio_values` push payload, with the legacy `has_current_value` flag still present until the handler is trimmed. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `fetch_live_portfolios` aggregates the canonical metrics and `_live_portfolios_payload` forwards them to the websocket caller.【F:custom_components/pp_reader/data/db_access.py†L939-L1041】【F:custom_components/pp_reader/data/websocket.py†L476-L532】 |
| `last_file_update` | ISO 8601 datetime string | Footer metadata card | Provides the last import timestamp in the same format as the push event. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_emit_last_file_update` and `ws_get_dashboard_data` both format the stored timestamp with the Europe/Berlin timezone before returning it.【F:custom_components/pp_reader/data/coordinator.py†L200-L288】【F:custom_components/pp_reader/data/websocket.py†L556-L607】 |
| `transactions[]` | array of recent transactions | Transaction activity table | Snapshot-only companion data that remains untouched by the overview harmonisation. | 1. passed from portfolio file and stored in database | `DataUpdateCoordinator` keeps the last transactions list in memory, and `ws_get_dashboard_data` includes it verbatim for the frontend cache.【F:custom_components/pp_reader/data/websocket.py†L548-L607】 |

## Account summaries (snapshot slice of `pp_reader/get_dashboard_data`; live updates via `accounts` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `accounts` | array of account objects | Overview liquidity tables | Ordered list of all investment and cash accounts displayed in the overview. | 1. passed from portfolio file and stored in database | Portfolio file streams repeated `PAccount` entries through `PClient.accounts`, and `_sync_accounts` upserts each payload into the SQLite `accounts` table for API reads. |
| `accounts[].name` | string | Liquidity tables | Human-readable account name rendered verbatim. | 1. passed from portfolio file and stored in database | The importer maps `PAccount.name` directly into `accounts.name`, so the UI receives the exact label supplied by the portfolio file. |
| `accounts[].currency_code` | string (ISO 4217) | EUR/FX grouping headers & currency badges | Currency associated with the account. | 1. passed from portfolio file and stored in database | Proto `PAccount.currencyCode` is a string field and `_sync_accounts` writes it into the SQLite `accounts.currency_code` column so the frontend sees the original code. |
| `accounts[].orig_balance` | number (account currency) | FX account table | Account balance expressed in the original account currency. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_load_accounts_payload` converts stored cent totals to floats via `cent_to_eur`, preserving the native amount for display.【F:custom_components/pp_reader/data/websocket.py†L82-L123】 |
| `accounts[].balance` | number (EUR or null) | EUR account table, totals calculations | Canonical EUR valuation for the account; `null` when FX data is missing. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_load_accounts_payload` divides the native balance by the Frankfurter rate fetched via `ensure_exchange_rates_for_dates`/`load_latest_rates` and rounds the result.【F:custom_components/pp_reader/data/websocket.py†L82-L134】 |
| `accounts[].fx_unavailable` | boolean (optional) | FX warning badges | Indicates missing FX data for non-EUR accounts; omitted when conversion succeeded. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_load_accounts_payload` sets the flag when no rate is available for the account currency; the push helper forwards the boolean unchanged.【F:custom_components/pp_reader/data/websocket.py†L90-L123】 |

## Portfolio summaries (snapshot slice of `pp_reader/get_dashboard_data`; live updates via `portfolio_values` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `portfolios` | array of portfolio summary objects | Portfolio overview table | Collection of portfolio aggregates aligned with the frontend ordering. | 1. passed from portfolio file and stored in database | Repeated `PPortfolio` entries from `PClient.portfolios` are inserted by `_sync_portfolios` into the `portfolios` table, preserving the order for API reads. |
| `portfolios[].uuid` | string (UUID) | Portfolio table row keys & push update matching | Primary key matching the backend `portfolios` table. | 1. passed from portfolio file and stored in database | `PPortfolio.uuid` (string) arrives via the portfolio file and `_sync_portfolios` writes it directly into `portfolios.uuid`, so the frontend keys rows off the persisted proto identifier. |
| `portfolios[].name` | string | Portfolio table first column | Portfolio display name shown in the overview. | 1. passed from portfolio file and stored in database | `_sync_portfolios` copies `PPortfolio.name` into the SQLite `portfolios.name` column, ensuring the UI renders the exact label from the import. |
| `portfolios[].position_count` | integer | “Anzahl Positionen” column | Persisted count of active positions. | 4. Calculate and stored inside the database. | `_sync_portfolio_securities` persists each holding's `current_holdings` in `portfolio_securities`, and `fetch_live_portfolios` returns `COUNT(CASE WHEN ps.current_holdings > 0 THEN 1 END)` so SQLite hands the pre-counted total to the API. |
| `portfolios[].current_value` | number (EUR) | “Aktueller Wert” column & totals | Current market value already converted to EUR. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `fetch_live_portfolios` sums `portfolio_securities.current_value` cents, `_normalize_portfolio_row` converts the aggregate to EUR, and `_live_portfolios_payload` forwards that `current_value` straight to websocket clients.【F:custom_components/pp_reader/data/db_access.py†L939-L1041】【F:custom_components/pp_reader/data/event_push.py†L44-L90】 |
| `portfolios[].purchase_sum` | number (EUR) | Hidden totals dataset | Total invested capital in EUR used for performance calculations. | 4. Calculate and stored inside the database. | `_sync_portfolio_securities` stores aggregated `purchase_value` cents per holding, `fetch_live_portfolios` sums `ps.purchase_value`, and `_normalize_portfolio_row` converts that cent total to EUR for the payload.【F:custom_components/pp_reader/data/db_access.py†L939-L1041】 |
| `portfolios[].missing_value_positions` | integer | Warning badge + totals guard | Count of holdings lacking valuation data. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `fetch_live_portfolios` aggregates NULL-valued holdings into `missing_value_positions`, `_normalize_portfolio_row` keeps the count on each entry, and `_normalize_portfolio_value_entry` forwards it unchanged in push payloads.【F:custom_components/pp_reader/data/db_access.py†L939-L1041】【F:custom_components/pp_reader/data/event_push.py†L44-L90】 |
| `portfolios[].performance.gain_abs` | number (EUR) | Gain column (absolute) | Absolute gain supplied directly by backend calculations. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `select_performance_metrics` derives `gain_abs` from the aggregated purchase/current sums, `_normalize_portfolio_row` serialises it, and `_normalize_portfolio_value_entry` forwards the nested dict without modification.【F:custom_components/pp_reader/data/db_access.py†L939-L1041】【F:custom_components/pp_reader/metrics/common.py†L60-L118】【F:custom_components/pp_reader/data/event_push.py†L44-L90】 |
| `portfolios[].performance.gain_pct` | number (%) | Gain column (percentage) | Percentage gain derived by backend logic. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | The same helper computes `PerformanceMetrics.gain_pct` from the aggregated purchase/current sums and the push compactor forwards it unchanged.【F:custom_components/pp_reader/data/db_access.py†L939-L1041】【F:custom_components/pp_reader/metrics/common.py†L60-L118】【F:custom_components/pp_reader/data/event_push.py†L44-L90】 |
| `portfolios[].performance.total_change_eur` | number (EUR) | Footer totals | Mirrors `gain_abs` for compatibility with existing frontend metrics. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `PerformanceMetrics.total_change_eur` is populated alongside `gain_abs`; the push compactor leaves the value untouched.【F:custom_components/pp_reader/metrics/common.py†L60-L118】【F:custom_components/pp_reader/data/event_push.py†L44-L90】 |
| `portfolios[].performance.total_change_pct` | number (%) | Footer totals | Mirrors `gain_pct` for compatibility with existing frontend metrics. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `PerformanceMetrics.total_change_pct` mirrors the percentage gain and is forwarded unchanged.【F:custom_components/pp_reader/metrics/common.py†L60-L118】【F:custom_components/pp_reader/data/event_push.py†L44-L90】 |
| `portfolios[].performance.source` | enum (`calculated`, `defaulted`) | Tooltip context | Indicates whether the gain metrics used backend data or fallbacks. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `select_performance_metrics` stamps the source and `_normalize_portfolio_value_entry` forwards the string as-is.【F:custom_components/pp_reader/metrics/common.py†L96-L118】【F:custom_components/pp_reader/data/event_push.py†L44-L90】 |
| `portfolios[].performance.coverage_ratio` | number (0–1, optional) | Tooltip context | Coverage of the inputs used to compute the performance metrics. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_coverage_ratio` reports the share of inputs present; the resulting float is included in the nested `performance` mapping.【F:custom_components/pp_reader/metrics/common.py†L40-L59】【F:custom_components/pp_reader/data/event_push.py†L44-L90】 |

## Portfolio positions (`pp_reader/get_portfolio_positions` command, `portfolio_positions` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `portfolio_id` | string (UUID) | Expandable table container | Identifies which portfolio the enclosed positions belong to. | 1. passed from portfolio file and stored in database | Portfolio uploads stream `PPortfolio.uuid` strings inside `PClient.portfolios`, `_sync_portfolios` upserts each UUID into `portfolios.uuid`, and the `ws_get_portfolio_positions` response echoes the same value as `portfolio_uuid` for the frontend container. |
| `positions` | array of position objects | Positions detail tables | Ordered holdings for the selected portfolio. | 1. passed from portfolio file and stored in database | Portfolio transactions carry the `PTransaction.portfolio`/`security` strings, `_sync_transactions` persists them into `transactions.portfolio` and `.security`, `_sync_portfolio_securities` aggregates those records into `portfolio_securities`, and the normalization pipeline reads the staged rows plus `security_metrics` to emit the ordered list. |
| `positions[].position_id` | string (UUID) | Row dataset attributes & diffing | Stable identifier for the position row within the portfolio. | 4. Calculate and stored inside the database. | The normalization pipeline still emits rows keyed by `security_uuid` without generating a separate `position_id`, so we need a follow-up to persist and expose a dedicated identifier. |
| `positions[].portfolio_id` | string (UUID) | Push reconciliation | Portfolio identifier repeated for differential updates. | 1. passed from portfolio file and stored in database | `PPortfolio.uuid` arrives as a string, `_sync_portfolios` upserts it into `portfolios.uuid`, and both the normalization pipeline and the websocket response filter and emit rows by that stored UUID for each positions payload. |
| `positions[].security_id` | string (UUID) | Row dataset attributes & detail navigation | Security identifier used to open the detail tab. | 1. passed from portfolio file and stored in database | `PSecurity.uuid` is persisted via `_sync_securities` into `securities.uuid`, and the normalization pipeline selects the matching `security_uuid` so each position keeps the proto-provided key. |
| `positions[].name` | string | Positions table first column | Security label rendered verbatim. | 1. passed from portfolio file and stored in database | `PSecurity.name` is written to `securities.name` inside `_sync_securities`, and the normalization pipeline joins that column when serialising each position. |
| `positions[].quantity` | number (supports fractional) | “Bestand” column | Persisted holdings amount with backend precision. | 4. Calculate and stored inside the database. | `db_calculate_current_holdings` collapses transactions into share totals per `(portfolio, security)` pair, `_sync_portfolio_securities` writes those `current_holdings` into SQLite, and the normalization pipeline feeds the stored value through its aggregation helpers so the response emits the precomputed quantity. |
| `positions[].current_value_eur` | number (EUR) | “Aktueller Wert” column & totals | EUR market value supplied directly by the backend. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | The normalization pipeline converts the stored `current_value_cents` to EUR before returning `current_value`, and the websocket layer only rounds and forwards that field to clients. 【F:custom_components/pp_reader/data/normalization_pipeline.py†L480-L560】【F:custom_components/pp_reader/data/websocket.py†L360-L404】 |
| `positions[].purchase_value_eur` | number (EUR) | Hidden dataset & FX tooltip | Aggregate purchase cost per holding for gain and disclosure logic. | 4. Calculate and stored inside the database. | `_sync_portfolio_securities` persists each holding’s EUR `purchase_value` as cents in SQLite, and the normalization pipeline converts that stored cent total to EUR before returning it in the payload. |
| `positions[].average_cost.primary.value` | number | “Ø Kaufpreis” primary line | Average price per unit in the security currency. Shares the same dataset as the security snapshot average cost. | 4. Calculate and stored inside the database. | `db_calculate_sec_purchase_value` computes the security-currency purchase totals, the price cycle writes those totals into `security_metrics`, and the normalization pipeline derives `average_cost["security"]` by dividing the stored `purchase_total_security` by `total_holdings`. |
| `positions[].average_cost.primary.currency` | string (ISO 4217) | “Ø Kaufpreis” primary line | Currency code for the primary average price. | 1. passed from portfolio file and stored in database | The same `PSecurity.currencyCode` persisted on `securities.currency_code` should label these averages, but `AverageCostSelection`/normalization still emit numeric slots with no currency tag today, so we should extend the average_cost payload to include the stored code. |
| `positions[].security_currency_code` | string (ISO 4217) | Currency badges | Trading currency for the security, reused in tooltips and formatting. | 1. passed from portfolio file and stored in database | Portfolio proto exposes `PSecurity.currencyCode` (string) and `_sync_securities` writes it to `securities.currency_code`, but the normalization pipeline currently falls back to inferred codes, so we need a follow-up to forward the stored currency with each position. |
| `positions[].performance.gain_eur` | number (EUR) | Gain column (absolute) | Direct gain metric delivered by the backend. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | The normalization pipeline feeds the EUR purchase/current totals into `select_performance_metrics`, and the websocket formatter forwards the resulting `performance.gain_abs` field unchanged to clients.【F:custom_components/pp_reader/data/normalization_pipeline.py†L480-L560】【F:custom_components/pp_reader/metrics/common.py†L83-L150】【F:custom_components/pp_reader/data/websocket.py†L360-L404】 |
| `positions[].performance.day_change.value_native` | number | Tagesänderung tooltip & delta badges | Day price delta mirrored from the security snapshot for quick comparison. | 4. Calculate and stored inside the database. | The normalization pipeline joins the persisted day-change fields from `security_metrics` so each row forwards the native delta without recomputing, letting the overview table show the same change used in the detail view. |
| `positions[].valuation_state.status` | enum (`complete`, `partial`, `missing`) | Warning icons & dataset metadata | Backend evaluation of valuation completeness for the holding. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: the positions payload assembled by the normalization pipeline lacks any valuation keys today, so we still need to derive and attach the enum before responding.【F:custom_components/pp_reader/data/normalization_pipeline.py†L480-L560】【F:custom_components/pp_reader/data/websocket.py†L360-L404】 |
| `positions[].valuation_state.reason` | string (optional) | Warning tooltip | Optional explanation for non-`complete` statuses. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: the normalization pipeline only returns holdings, pricing, and performance fields today, so we still need to derive valuation flags (e.g., missing market prices) and attach the explanatory reason when building the websocket payload. 【F:custom_components/pp_reader/data/normalization_pipeline.py†L480-L560】【F:custom_components/pp_reader/data/websocket.py†L360-L404】 |

| `positions[].data_state.status` | enum (`ok`, `error`) | Inline error banner | Declares whether the backend detected an error while assembling the positions payload. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: `ws_get_portfolio_positions` still returns a top-level `error` string on missing portfolios or loader failures, so we need to map those outcomes into per-position `data_state.status` values before emitting the payload. 【F:custom_components/pp_reader/data/websocket.py†L1004-L1069】 |
| `positions[].data_state.message` | string (optional) | Inline error banner | Human-readable error message shown when `status` is `error`. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: the websocket handler only surfaces failure text via the response-level `error` field today, so the normalization step must copy that string into each position’s `data_state.message` when `status` is `error`. 【F:custom_components/pp_reader/data/websocket.py†L1004-L1069】 |

## Last file update (snapshot slice of `pp_reader/get_dashboard_data`; live updates via `last_file_update` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `last_file_update` | ISO 8601 datetime string | Footer card metadata & header fallback | Timestamp of the most recent portfolio import processed by the backend. The push payload and snapshot share the same formatted string. | 4. Calculate and stored inside the database. | `_SyncRunner._store_last_file_update` upserts the truncated ISO timestamp into `metadata('last_file_update')`, `_emit_last_file_update` formats it with the Europe/Berlin timezone, and `ws_get_dashboard_data` mirrors the same value for snapshot consumers.【F:custom_components/pp_reader/data/sync_from_pclient.py†L1394-L1430】【F:custom_components/pp_reader/data/websocket.py†L556-L607】 |

## Security snapshot (`pp_reader/get_security_snapshot` command, `security_snapshot` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `security_id` | string (UUID) | Detail tab routing & shared dataset keys | Canonical identifier tying the snapshot to the selected security. | 1. passed from portfolio file and stored in database | Portfolio file passes `PSecurity.uuid`, `_sync_securities` writes it into `securities.uuid`, and the snapshot lookup queries by that UUID. |
| `snapshot_timestamp` | ISO 8601 datetime string | Header metadata | Timestamp representing when the snapshot values were recorded. | 4. Calculate and stored inside the database. | `get_security_snapshot` and `_serialise_security_snapshot` return holdings and pricing data but never include a timestamp yet, so we need a follow-up to persist the snapshot instant (e.g. reuse `metadata.last_file_update`) and expose it with the payload. |
| `name` | string | Detail header title | Security display name shown in the detail view. | 1. passed from portfolio file and stored in database | `PSecurity.name` persists into `securities.name` via `_sync_securities`, and `get_security_snapshot` surfaces the stored value. |
| `currency_code` | string (ISO 4217) | Header metadata & chart legend | Trading currency for all price figures. | 1. passed from portfolio file and stored in database | `PSecurity.currencyCode` flows into `securities.currency_code` through `_sync_securities`, which `get_security_snapshot` reads for the snapshot currency. |
| `account_currency_code` | string (ISO 4217, optional) | FX tooltip | Account currency associated with the position when different from the security currency. | 1. passed from portfolio file and stored in database | Portfolio proto supplies `PPortfolio.referenceAccount` and the linked `PAccount.currencyCode` strings, which `_sync_portfolios` and `_sync_accounts` persist into `portfolios.reference_account` and `accounts.currency_code` so the snapshot can read the holder’s account currency. |
| `holdings.total_units` | number | Header “Bestand” block | Total units owned according to the latest snapshot. | 4. Calculate and stored inside the database. | `_sync_portfolio_securities` persists each `(portfolio, security)` `current_holdings` computed by `db_calculate_current_holdings`, and `get_security_snapshot` sums those stored rows via `compute_holdings_aggregation` to deliver the precomputed total. |
| `holdings.precise_units` | number (optional) | Header “Bestand” block tooltip | High-precision units when available. | 4. Calculate and stored inside the database. | `get_security_snapshot` only returns the rounded `total_holdings`, so we still need to surface the raw `portfolio_securities.current_holdings` (stored in 10⁻⁸ units per `data/db_schema.py`) as a dedicated precise value. |
| `last_price.native_value` | number | “Letzter Preis” block & chart stitching | Latest trade price delivered already scaled in the security currency. | 2. Yahoo query life fetch store in database. | Yahoo’s `20251011_AAPL_full_set.md` sample exposes `regularMarketPrice`, `YahooQueryProvider.fetch` copies that field into each `Quote`, and `_run_price_cycle` hands the scaled value to `_apply_price_updates`, which writes `securities.last_price`. |
| `last_price.account_value` | number (optional) | “Letzter Preis” secondary display | Converted last price supplied when available (EUR/account currency). | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: `get_security_snapshot` already converts the stored cent quote to EUR via `normalize_price_to_eur_sync` and `_serialise_security_snapshot` emits it as `last_price_eur`, but we still need to surface that figure under the documented `last_price.account_value` key. 【F:custom_components/pp_reader/data/db_access.py†L521-L660】【F:custom_components/pp_reader/data/websocket.py†L148-L205】 |
| `last_price.market_time` | ISO 8601 datetime string | “Letzter Preis” block subtitle | Market timestamp associated with the latest price, displayed alongside the quote in the detail header. | 2. Yahoo query life fetch store in database. | `_apply_price_updates` persists Yahoo quote timestamps into `securities.last_price_time`; the snapshot forwards that string so the UI can render the precise market instant next to `last_price.native_value`. |
| `last_price.fetched_at` | ISO 8601 datetime string | Detail footer freshness row | Timestamp when the backend fetched the latest price batch. | 2. Yahoo query life fetch store in database. | `_run_price_cycle` derives `_utc_now_iso()` for each Yahoo batch and passes it into `_apply_price_updates`, which persists the stamp in `securities.last_price_fetched_at`; the snapshot surfaces it for display in the security detail footer. |
| `market_value_eur` | number (EUR) | “Marktwert (EUR)” block | Market value expressed in EUR. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `get_security_snapshot` multiplies the aggregated holdings by the converted EUR last price to derive `market_value_eur`, and `_serialise_security_snapshot` rounds and returns that number in the websocket payload. 【F:custom_components/pp_reader/data/db_access.py†L532-L660】【F:custom_components/pp_reader/data/websocket.py†L148-L196】 |
| `purchase_value_eur` | number (EUR) | FX tooltip context | Total purchase value in EUR used for gain calculations. | 4. Calculate and stored inside the database. | `_sync_portfolio_securities` writes each holding’s EUR `purchase_value` cents into SQLite, `compute_holdings_aggregation` converts those cents via `cent_to_eur`, and `get_security_snapshot` returns the aggregated EUR total in the payload. |
| `average_cost.primary.value` | number | Average purchase card primary line | Shares the same backend dataset as `positions[].average_cost.primary.value`. | 4. Calculate and stored inside the database. | `db_calculate_sec_purchase_value` computes the security-currency totals and averages, `_run_price_cycle` upserts them into `portfolio_securities.security_currency_total`, and `select_average_cost`/`_resolve_average_cost_totals` in `get_security_snapshot` emit that average as the primary value. |
| `average_cost.primary.currency` | string (ISO 4217) | Average purchase card primary line | Currency code for the primary average purchase price. | 1. passed from portfolio file and stored in database | The portfolio file exposes `PSecurity.currencyCode` (string), and `_sync_securities` writes it into `securities.currency_code`, which `get_security_snapshot` selects for the primary average-cost currency. |
| `average_cost.secondary.value` | number (EUR, optional) | Average purchase card secondary line | Average price converted from the primary value into EUR by applying the backend FX translation. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_resolve_average_cost_totals` calls `select_average_cost`, which divides the EUR purchase totals by the share counts to populate `selection.eur`, and `get_security_snapshot` with `_serialise_security_snapshot` forwards that dataclass so the websocket payload already includes the converted average price.【F:custom_components/pp_reader/data/aggregations.py†L176-L260】【F:custom_components/pp_reader/data/db_access.py†L574-L666】【F:custom_components/pp_reader/data/websocket.py†L186-L205】 |
| `average_cost.secondary.currency` | string (`"EUR"`, optional) | Average purchase card secondary line | Always `EUR`; matches the converted secondary average price. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `AverageCostSelection` only exposes numeric fields (`native`, `security`, `account`, `eur`) and `_serialise_security_snapshot` emits that mapping unchanged, so we still need to add an explicit `"EUR"` currency string alongside the secondary value before the frontend can display it.【F:custom_components/pp_reader/data/aggregations.py†L49-L69】【F:custom_components/pp_reader/data/websocket.py†L197-L205】 |
| `average_cost.fx_rate_timestamp` | ISO 8601 datetime string (nullable) | Tooltip FX timestamp | Timestamp of the FX rate supporting the converted average price. | 3. Frankfurt, APIFX fetch store and database. | `get_security_snapshot` reads the aggregated purchase metrics produced by `db_calculate_sec_purchase_value`, so once that flow’s Frankfurter fetch (`ensure_exchange_rates_for_dates_sync` + `load_latest_rates_sync` on `fx_rates`) exposes its rate date we can emit it with the snapshot averages. |
| `performance.total.gain_eur` | number (EUR) | Total gain tile | Total gain provided by backend calculations. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `select_performance_metrics` computes `gain_abs` from the EUR market and purchase totals and mirrors it into `total_change_eur`, and `get_security_snapshot` serialises that `performance` mapping into the websocket payload, so the frontend receives the precomputed EUR gain value directly.【F:custom_components/pp_reader/metrics/common.py†L83-L148】【F:custom_components/pp_reader/data/db_access.py†L631-L667】 |
| `performance.total.gain_pct` | number (%) | Total gain tile | Total gain percentage delivered by the backend. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `select_performance_metrics` computes `gain_pct` (and mirrors it into `total_change_pct`) from the stored market and purchase values, and `get_security_snapshot` serialises that structure into the websocket payload.【F:custom_components/pp_reader/metrics/common.py†L83-L161】【F:custom_components/pp_reader/data/db_access.py†L631-L667】 |
| `performance.day_change.value_native` | number | “Tagesänderung” block | Day price change in the security currency. | 4. Calculate and stored inside the database. | The price cycle compares `securities.last_price` against the most recent `historical_prices.close` for the same security and persists the delta in `securities.day_change_native`, which the snapshot exposes unchanged. |
| `performance.day_change.value_eur` | number (optional) | “Tagesänderung” block | Day price change converted to EUR. | 4. Calculate and stored inside the database. | After computing the native delta the backend multiplies it by the freshest Frankfurter FX rate (when present) and stores the result in `securities.day_change_eur`; the snapshot reuses that persisted EUR change. |
| `performance.day_change.pct` | number (%) | “Tagesänderung” block | Day percentage change persisted by backend. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | The delta stored in `securities.day_change_native` combines with the persisted previous close to derive `change_pct`, which the snapshot serializer forwards after rounding.【F:custom_components/pp_reader/metrics/common.py†L131-L159】【F:custom_components/pp_reader/data/db_access.py†L631-L667】 |
| `performance.day_change.coverage_ratio` | number (0–1, optional) | Tooltip | Coverage of the day change data when incomplete. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_coverage_ratio` measures how many native prices were available for the day-change computation, and the snapshot serializer forwards that coverage flag alongside the other metrics in the emitted payload.【F:custom_components/pp_reader/metrics/common.py†L48-L61】【F:custom_components/pp_reader/metrics/common.py†L137-L159】【F:custom_components/pp_reader/data/db_access.py†L631-L667】 |
| `performance.day_change.source` | enum (`market`, `estimated`, `cached`) | Tooltip | Provenance of the day change values. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `select_performance_metrics` labels the day-change origin (`native`, `eur`, or `unavailable`) based on which inputs were present, and `get_security_snapshot` passes that enum straight through to the websocket payload for display.【F:custom_components/pp_reader/metrics/common.py†L137-L159】【F:custom_components/pp_reader/data/db_access.py†L631-L667】 |
| `purchase_totals.security_currency` | number | FX tooltip | Aggregate purchase value in the security currency. | 4. Calculate and stored inside the database. | `db_calculate_sec_purchase_value` totals each holding’s native spend into `security_currency_total`【F:custom_components/pp_reader/logic/securities.py†L520-L538】, `_run_price_cycle` writes those totals into `portfolio_securities.security_currency_total` for every impacted pair【F:custom_components/pp_reader/prices/price_service.py†L538-L666】, and `compute_holdings_aggregation` with `get_security_snapshot` sum the stored column into the emitted `purchase_total_security` value.【F:custom_components/pp_reader/data/aggregations.py†L85-L138】【F:custom_components/pp_reader/data/db_access.py†L643-L651】 |
| `purchase_totals.account_currency` | number (EUR, optional) | FX tooltip | Aggregate purchase value converted to EUR by the backend, regardless of the account currency used at purchase time. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `get_security_snapshot` feeds `_resolve_average_cost_totals` and attaches its `purchase_total_account` to the aggregation map, and `_serialise_security_snapshot` rounds that value so the payload exposes the backend-converted EUR total.【F:custom_components/pp_reader/data/db_access.py†L573-L651】【F:custom_components/pp_reader/data/websocket.py†L260-L266】 |
| `purchase_fx.rate` | number | FX tooltip | Exchange rate used for conversions in the purchase context. | 3. Frankfurt, APIFX fetch store and database. | `custom_components/pp_reader/logic/securities.py::db_calculate_sec_purchase_value` gathers non-EUR transaction dates and calls `ensure_exchange_rates_for_dates_sync`; the Frankfurter client (`currencies/fx.py::_fetch_exchange_rates`) hits `https://api.frankfurter.app/{date}?from=EUR&to={symbols}` and `_save_rates_sync` upserts into the SQLite `fx_rates (date, currency, rate)` table declared in `data/db_schema.py`, then `_determine_exchange_rate` reloads the stored number via `load_latest_rates_sync`, so we just need to expose that persisted value on the snapshot serializer. |
| `purchase_fx.currency_pair` | string | FX tooltip | Currency pair used for the exchange rate. | 3. Frankfurt, APIFX fetch store and database. | Because `_fetch_exchange_rates` always requests `from=EUR`, `_save_rates_sync` records each term currency under `fx_rates.currency`, letting the serializer label the stored rate as `EUR/{tx.currency_code}` once the metadata is forwarded with the snapshot payload. |
| `purchase_fx.as_of` | ISO 8601 datetime string | FX tooltip “Stand” line | Timestamp associated with `purchase_fx.rate`. | 3. Frankfurt, APIFX fetch store and database. | `ensure_exchange_rates_for_dates_sync` iterates every transaction timestamp, formats it via `dt.strftime("%Y-%m-%d")`, and `_save_rates_sync` keeps that string as the `fx_rates.date` primary key, so wiring the saved metadata into the snapshot will surface the persisted rate date. |
| `data_source` | enum (`live`, `cache`, `historic`) | Cached data notice | Indicates whether the snapshot originates from live or cached data. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `get_security_snapshot` and `_serialise_security_snapshot` currently emit only pricing, aggregation, and performance keys, leaving `data_source` unset, so we still need follow-up logic to tag snapshots as live/cache/historic before sending them.【F:custom_components/pp_reader/data/db_access.py†L654-L667】【F:custom_components/pp_reader/data/websocket.py†L240-L292】 |
| `last_transaction_at` | ISO 8601 datetime string (nullable) | Meta section optional row | Timestamp for the most recent trade involving the security. | 4. Calculate and stored inside the database. | The `transactions` table already stores each trade’s ISO `date` for later aggregation【F:custom_components/pp_reader/data/db_schema.py†L126-L148】, but `get_security_snapshot` still returns a payload without `last_transaction_at`, so we need a follow-up to compute and persist the latest transaction timestamp before emitting the snapshot.【F:custom_components/pp_reader/data/db_access.py†L643-L665】 |

## Security history (`pp_reader/get_security_history` command, `security_history` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `security_id` | string (UUID) | History chart container | Identifies which security the series belongs to. | 1. passed from portfolio file and stored in database | Security UUIDs arrive via `PSecurity.uuid`, `_sync_securities` stores them in `securities.uuid`, and the same key is used when persisting `historical_prices.security_uuid` for history queries. |
| `range` | string (`1M`, `3M`, `1Y`, `5Y`, `ALL`, etc.) | Range selector dataset | Confirms which pre-computed window the backend returned. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `ws_get_security_history` echoes provided `start_date`/`end_date` bounds for the frontend cache. |
| `series_source` | enum (`portfolio_performance`, `market_data`) | Chart legend | States where the price series originated. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Portfolio imports write every `security.prices` row into `historical_prices` without tagging the origin, so once the Yahoo history ingest lands we must persist a source flag (e.g. new column or join table) and let the history serializer map it to `portfolio_performance` vs `market_data` for the legend.【F:custom_components/pp_reader/data/db_schema.py†L57-L73】【F:custom_components/pp_reader/data/sync_from_pclient.py†L1090-L1144】 |
| `prices` | array of price points ordered by date | History chart | Time-series data for plotting. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `iter_security_close_prices` streams stored closes from `historical_prices`; the websocket forwards them unchanged.【F:custom_components/pp_reader/data/db_access.py†L606-L666】【F:custom_components/pp_reader/data/websocket.py†L774-L833】 |
| `prices[].date` | integer YYYYMMDD | Chart axis | Daily timestamp of the price point. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Portfolio ingestion stores integer day codes in `historical_prices.date`; the iterator returns the stored value directly.【F:custom_components/pp_reader/data/db_access.py†L606-L666】 |
| `prices[].close_native` | number | Chart series | Closing price in the security currency. | 2. Yahoo query life fetch store in database. | Yahoo exposes `close` values alongside each date, but the current importer only copies proto closes into `historical_prices.close`, leaving a follow-up to map the Yahoo field into that column. |
| `prices[].close_eur` | number (optional) | EUR overlay & tooltips | Closing price converted to EUR when supplied. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | The history handler already streams native closes from `iter_security_close_prices`, so we need to extend it to call `normalize_price_to_eur_sync` (same helper used for snapshot `last_close_eur`) per row and emit the rounded EUR value alongside the native series.【F:custom_components/pp_reader/data/websocket.py†L811-L880】【F:custom_components/pp_reader/util/currency.py†L114-L176】【F:custom_components/pp_reader/data/db_access.py†L606-L665】【F:tests/test_db_access.py†L893-L939】 |
| `transactions` | array of transaction marker objects | History chart annotations | Purchases, sales, inbound deliveries, and outbound deliveries filtered by range. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `get_security_transactions` collects types 0/1/2/3 with fees/taxes, `async_fetch_security_history` normalises shares, gross native price, and net EUR price for sells, and `ws_get_security_history` returns them alongside prices.【F:custom_components/pp_reader/data/db_access.py†L520-L620】【F:custom_components/pp_reader/data/normalization_pipeline.py†L319-L395】【F:custom_components/pp_reader/data/websocket.py†L774-L833】 |
| `transactions[].uuid` | string (UUID) | Marker ID | Transaction identifier used to dedupe markers. | 1. passed from portfolio file and stored in database | `transactions.uuid` is persisted during ingestion and forwarded unchanged when present. |
| `transactions[].type` | enum (`0`, `1`, `2`, `3`) | Marker style mapping | Raw transaction type; 0/2 treated as buy, 1/3 as sell. | 1. passed from portfolio file and stored in database | Proto `PTransaction.type` is stored in `transactions.type` and forwarded verbatim. |
| `transactions[].date` | ISO 8601 date string | Marker position | Trade date; marker renders only when a valid date exists. | 1. passed from portfolio file and stored in database | `transactions.date` is stored as ISO text and sent back as-is. |
| `transactions[].shares` | number | Marker label and per-share math | Share count normalised from 10⁻⁸ raw holdings. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `normalize_shares` converts stored integer holdings into floats during history serialization.【F:custom_components/pp_reader/data/normalization_pipeline.py†L338-L395】 |
| `transactions[].price` | number | Marker y-axis | Gross per-share price in the native currency. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `async_fetch_security_history` divides the native amount by shares and rounds to 4 decimals.【F:custom_components/pp_reader/data/normalization_pipeline.py†L338-L395】 |
| `transactions[].net_price_eur` | number (optional) | Marker tooltip for sells | Net EUR per-share (gross minus fees/taxes) for sale types. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Sells compute net cents less fees/taxes, convert to EUR, divide by shares, and round to 4 decimals in `async_fetch_security_history`.【F:custom_components/pp_reader/data/normalization_pipeline.py†L338-L395】 |
| `transactions[].currency_code` | string (ISO 4217) | Marker label currency | Native currency code for the trade. | 1. passed from portfolio file and stored in database | Stored `transactions.currency_code` is uppercased during serialization and forwarded. |
| `transactions[].amount` | integer (cents) | Marker tooltip calculations | Gross transaction amount in native cents. | 1. passed from portfolio file and stored in database | `transactions.amount` is persisted and forwarded to allow frontend tooltip math. |
| `transactions[].fees` | integer (cents, optional) | Marker tooltip calculations | Total fees in native cents aggregated from transaction units. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `get_security_transactions` sums `transaction_units` of type 2 per transaction and returns the cent total.【F:custom_components/pp_reader/data/db_access.py†L520-L620】 |
| `transactions[].taxes` | integer (cents, optional) | Marker tooltip calculations | Total taxes in native cents aggregated from transaction units. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `get_security_transactions` sums `transaction_units` of type 1 per transaction and returns the cent total.【F:custom_components/pp_reader/data/db_access.py†L520-L620】 |

## Live update envelope (`panels_updated` bus)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `data_type` | enum (`accounts`, `portfolio_values`, `portfolio_positions`, `last_file_update`, `security_snapshot`, `security_history`) | `src/dashboard.ts` event handler | Discriminator instructing the dashboard which handler should process the payload. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_push_update` injects the `data_type` argument verbatim into each event payload, and its callers pass the canonical literals (`"accounts"`, `"portfolio_values"`, `"portfolio_positions"`, etc.), so the frontend receives the correct discriminator for every bus message.【F:custom_components/pp_reader/data/event_push.py†L214-L229】【F:custom_components/pp_reader/data/sync_from_pclient.py†L1424-L1562】【F:custom_components/pp_reader/prices/price_service.py†L1078-L1133】 |
| `payload` | object matching the schemas above | Delegated modules | Dataset delivered to the relevant handler without additional guards. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_compact_event_data` only removes redundant keys before `_push_update` nests the structure under `data`, so the handlers receive the same DB-backed payload objects that the importer or price service fetched prior to emission.【F:custom_components/pp_reader/data/event_push.py†L202-L229】【F:custom_components/pp_reader/data/sync_from_pclient.py†L1462-L1562】【F:custom_components/pp_reader/prices/price_service.py†L1078-L1133】 |
| `synced_at` | ISO 8601 datetime string (optional) | Debug overlay / logs | Timestamp indicating when the backend emitted the event. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_push_update` currently emits only `domain`, `entry_id`, `data_type`, and `data`, so we still need to add a timestamp (for example `dt_util.utcnow().isoformat()`) before the frontend can display `synced_at`.【F:custom_components/pp_reader/data/event_push.py†L224-L229】 |
