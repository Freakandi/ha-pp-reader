# Backend Canonical Data Model

This document consolidates the backend payloads required by the Portfolio Performance Reader frontend. Each field listed below matches the harmonised push event shapes so the UI can render without synthesising fallback data or duplicating calculations. The `pp_reader/get_dashboard_data` websocket call continues to provide the overview snapshot on initial load; that handler still returns its legacy field set (for example `has_current_value` on portfolio entries) while the push payloads described here remain the canonical source of truth for live updates.

**Recommendation:** The six backend data source options below cover the full set of frontend needs; no additional sourcing categories are required.

## Dashboard snapshot (`pp_reader/get_dashboard_data` command; push updates: `accounts`, `portfolio_values`, `portfolio_positions`, `last_file_update`)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `accounts[]` | array of account objects | Overview liquidity tables | Mirrors the `accounts` push payload (see below) so the frontend can render the EUR and FX tables before live events arrive. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_load_accounts_payload` prepares the same dictionaries used for push events; the websocket handler forwards them unchanged, including the optional `fx_unavailable` flag.【F:custom_components/pp_reader/data/websocket.py†L60-L134】 |
| `portfolios[]` | array of portfolio summary objects | Portfolio overview table | Mirrors the `portfolio_values` push payload, with the legacy `has_current_value` flag still present until the handler is trimmed. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `fetch_live_portfolios` aggregates the canonical metrics and `_live_portfolios_payload` forwards them to the websocket caller.【F:custom_components/pp_reader/data/db_access.py†L939-L1041】【F:custom_components/pp_reader/data/websocket.py†L476-L532】 |
| `last_file_update` | ISO 8601 datetime string | Footer metadata card | Provides the last import timestamp in the same format as the push event. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_emit_last_file_update` and `ws_get_dashboard_data` both format the stored timestamp with the Europe/Berlin timezone before returning it.【F:custom_components/pp_reader/data/sync_from_pclient.py†L1394-L1430】【F:custom_components/pp_reader/data/websocket.py†L556-L607】 |
| `transactions[]` | array of recent transactions | Transaction activity table | Snapshot-only companion data that remains untouched by the overview harmonisation. | 1. passed from portfolio file and stored in database | `DataUpdateCoordinator` keeps the last transactions list in memory, and `ws_get_dashboard_data` includes it verbatim for the frontend cache.【F:custom_components/pp_reader/data/websocket.py†L548-L607】 |

## Account summaries (snapshot slice of `pp_reader/get_dashboard_data`; live updates via `accounts` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `accounts` | array of account objects | Overview liquidity tables | Ordered list of all investment and cash accounts displayed in the overview. | 1. passed from portfolio file and stored in database | Portfolio file streams repeated `PAccount` entries through `PClient.accounts`, and `_sync_accounts` upserts each payload into the SQLite `accounts` table for API reads. |
| `accounts[].name` | string | Liquidity tables | Human-readable account name rendered verbatim. | 1. passed from portfolio file and stored in database | The importer maps `PAccount.name` directly into `accounts.name`, so the UI receives the exact label supplied by the portfolio file. |
| `accounts[].currency_code` | string (ISO 4217) | EUR/FX grouping headers & currency badges | Currency associated with the account. | 1. passed from portfolio file and stored in database | Proto `PAccount.currencyCode` is a string field and `_sync_accounts` writes it into the SQLite `accounts.currency_code` column so the frontend sees the original code. |
| `accounts[].orig_balance` | number (account currency) | FX account table | Account balance expressed in the original account currency. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_load_accounts_payload` converts stored cent totals to floats via `cent_to_eur`, preserving the native amount for display.【F:custom_components/pp_reader/data/websocket.py†L82-L123】 |
| `accounts[].balance` | number (EUR or null) | EUR account table, totals calculations | Canonical EUR valuation for the account; `null` when FX data is missing. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_load_accounts_payload` divides the native balance by the Frankfurter rate fetched via `ensure_exchange_rates_for_dates`/`load_latest_rates` and rounds the result.【F:custom_components/pp_reader/data/websocket.py†L82-L134】 |
| `accounts[].fx_unavailable` | boolean (optional) | FX warning badges | Indicates missing FX data for non-EUR accounts; omitted when conversion succeeded. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_load_accounts_payload` sets the flag when no rate is available for the account currency; the push helper forwards the boolean unchanged.【F:custom_components/pp_reader/data/websocket.py†L90-L123】【F:custom_components/pp_reader/data/sync_from_pclient.py†L1353-L1393】 |

## Portfolio summaries (snapshot slice of `pp_reader/get_dashboard_data`; live updates via `portfolio_values` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `portfolios` | array of portfolio summary objects | Portfolio overview table | Collection of portfolio aggregates aligned with the frontend ordering. | 1. passed from portfolio file and stored in database | Repeated `PPortfolio` entries from `PClient.portfolios` are inserted by `_sync_portfolios` into the `portfolios` table, preserving the order for API reads. |
| `portfolios[].uuid` | string (UUID) | Portfolio table row keys & push update matching | Primary key matching the backend `portfolios` table. | 1. passed from portfolio file and stored in database | `PPortfolio.uuid` (string) arrives via the portfolio file and `_sync_portfolios` writes it directly into `portfolios.uuid`, so the frontend keys rows off the persisted proto identifier. |
| `portfolios[].name` | string | Portfolio table first column | Portfolio display name shown in the overview. | 1. passed from portfolio file and stored in database | `_sync_portfolios` copies `PPortfolio.name` into the SQLite `portfolios.name` column, ensuring the UI renders the exact label from the import. |
| `portfolios[].position_count` | integer | “Anzahl Positionen” column | Persisted count of active positions. | 4. Calculate and stored inside the database. | `_sync_portfolio_securities` persists each holding's `current_holdings` in `portfolio_securities`, and `fetch_live_portfolios` returns `COUNT(CASE WHEN ps.current_holdings > 0 THEN 1 END)` so SQLite hands the pre-counted total to the API. |
| `portfolios[].current_value` | number (EUR) | “Aktueller Wert” column & totals | Current market value already converted to EUR. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `fetch_live_portfolios` sums `portfolio_securities.current_value` cents, `_normalize_portfolio_row` converts the aggregate to EUR, and `_live_portfolios_payload` forwards that `current_value` straight to websocket clients.【F:custom_components/pp_reader/data/db_access.py†L939-L1041】【F:custom_components/pp_reader/data/event_push.py†L44-L90】 |
| `portfolios[].purchase_sum` | number (EUR) | Hidden totals dataset | Total invested capital in EUR used for performance calculations. | 4. Calculate and stored inside the database. | `_sync_portfolio_securities` stores aggregated `purchase_value` cents per holding, `fetch_live_portfolios` sums `ps.purchase_value`, and `_normalize_portfolio_row` converts that cent total to EUR for the payload.【F:custom_components/pp_reader/data/db_access.py†L939-L1041】 |
| `portfolios[].missing_value_positions` | integer | Warning badge + totals guard | Count of holdings lacking valuation data. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `fetch_live_portfolios` aggregates NULL-valued holdings into `missing_value_positions`, `_normalize_portfolio_row` keeps the count on each entry, and `_normalize_portfolio_value_entry` forwards it unchanged in push payloads.【F:custom_components/pp_reader/data/db_access.py†L939-L1041】【F:custom_components/pp_reader/data/event_push.py†L44-L90】 |
| `portfolios[].performance.gain_abs` | number (EUR) | Gain column (absolute) | Absolute gain supplied directly by backend calculations. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `select_performance_metrics` derives `gain_abs` from the aggregated purchase/current sums, `_normalize_portfolio_row` serialises it, and `_normalize_portfolio_value_entry` forwards the nested dict without modification.【F:custom_components/pp_reader/data/db_access.py†L939-L1041】【F:custom_components/pp_reader/data/performance.py†L60-L118】【F:custom_components/pp_reader/data/event_push.py†L44-L90】 |
| `portfolios[].performance.gain_pct` | number (%) | Gain column (percentage) | Percentage gain derived by backend logic. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | The same helper computes `PerformanceMetrics.gain_pct` from the aggregated purchase/current sums and the push compactor forwards it unchanged.【F:custom_components/pp_reader/data/db_access.py†L939-L1041】【F:custom_components/pp_reader/data/performance.py†L60-L118】【F:custom_components/pp_reader/data/event_push.py†L44-L90】 |
| `portfolios[].performance.total_change_eur` | number (EUR) | Footer totals | Mirrors `gain_abs` for compatibility with existing frontend metrics. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `PerformanceMetrics.total_change_eur` is populated alongside `gain_abs`; the push compactor leaves the value untouched.【F:custom_components/pp_reader/data/performance.py†L60-L118】【F:custom_components/pp_reader/data/event_push.py†L44-L90】 |
| `portfolios[].performance.total_change_pct` | number (%) | Footer totals | Mirrors `gain_pct` for compatibility with existing frontend metrics. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `PerformanceMetrics.total_change_pct` mirrors the percentage gain and is forwarded unchanged.【F:custom_components/pp_reader/data/performance.py†L60-L118】【F:custom_components/pp_reader/data/event_push.py†L44-L90】 |
| `portfolios[].performance.source` | enum (`calculated`, `defaulted`) | Tooltip context | Indicates whether the gain metrics used backend data or fallbacks. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `select_performance_metrics` stamps the source and `_normalize_portfolio_value_entry` forwards the string as-is.【F:custom_components/pp_reader/data/performance.py†L96-L118】【F:custom_components/pp_reader/data/event_push.py†L44-L90】 |
| `portfolios[].performance.coverage_ratio` | number (0–1, optional) | Tooltip context | Coverage of the inputs used to compute the performance metrics. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_coverage_ratio` reports the share of inputs present; the resulting float is included in the nested `performance` mapping.【F:custom_components/pp_reader/data/performance.py†L40-L59】【F:custom_components/pp_reader/data/event_push.py†L44-L90】 |

## Portfolio positions (`pp_reader/get_portfolio_positions` command, `portfolio_positions` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `portfolio_id` | string (UUID) | Expandable table container | Identifies which portfolio the enclosed positions belong to. | 1. passed from portfolio file and stored in database | Portfolio uploads stream `PPortfolio.uuid` strings inside `PClient.portfolios`, `_sync_portfolios` upserts each UUID into `portfolios.uuid`, and the `ws_get_portfolio_positions` response echoes the same value as `portfolio_uuid` for the frontend container. |
| `positions` | array of position objects | Positions detail tables | Ordered holdings for the selected portfolio. | 1. passed from portfolio file and stored in database | Portfolio transactions carry the `PTransaction.portfolio`/`security` strings, `_sync_transactions` persists them into `transactions.portfolio` and `.security`, `_sync_portfolio_securities` aggregates those records into `portfolio_securities`, and `get_portfolio_positions` returns that table as the `positions` list. |
| `positions[].position_id` | string (UUID) | Row dataset attributes & diffing | Stable identifier for the position row within the portfolio. | 4. Calculate and stored inside the database. | `get_portfolio_positions` still emits rows keyed by `security_uuid` without generating a separate `position_id`, so we need a follow-up to persist and expose a dedicated identifier. |
| `positions[].portfolio_id` | string (UUID) | Push reconciliation | Portfolio identifier repeated for differential updates. | 1. passed from portfolio file and stored in database | `PPortfolio.uuid` arrives as a string, `_sync_portfolios` upserts it into `portfolios.uuid`, and both `get_portfolio_positions` and the websocket response filter and emit rows by that stored UUID for each positions payload. |
| `positions[].security_id` | string (UUID) | Row dataset attributes & detail navigation | Security identifier used to open the detail tab. | 1. passed from portfolio file and stored in database | `PSecurity.uuid` is persisted via `_sync_securities` into `securities.uuid`, and `get_portfolio_positions` selects the matching `ps.security_uuid` so each position keeps the proto-provided key. |
| `positions[].name` | string | Positions table first column | Security label rendered verbatim. | 1. passed from portfolio file and stored in database | `PSecurity.name` is written to `securities.name` inside `_sync_securities`, and `get_portfolio_positions` joins that column (`s.name`) to populate the display label. |
| `positions[].quantity` | number (supports fractional) | “Bestand” column | Persisted holdings amount with backend precision. | 4. Calculate and stored inside the database. | `db_calculate_current_holdings` collapses transactions into share totals per `(portfolio, security)` pair, `_sync_portfolio_securities` writes those `current_holdings` into SQLite, and `get_portfolio_positions` feeds the stored value through `compute_holdings_aggregation` so the response emits the precomputed quantity. |
| `positions[].current_value_eur` | number (EUR) | “Aktueller Wert” column & totals | EUR market value supplied directly by the backend. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `get_portfolio_positions` converts the stored `portfolio_securities.current_value` cents to EUR before returning `current_value`, and `_normalize_portfolio_positions` only rounds and forwards that field to websocket clients. 【F:custom_components/pp_reader/data/db_access.py†L904-L924】【F:custom_components/pp_reader/data/websocket.py†L384-L401】 |
| `positions[].purchase_value_eur` | number (EUR) | Hidden dataset & FX tooltip | Aggregate purchase cost per holding for gain and disclosure logic. | 4. Calculate and stored inside the database. | `_sync_portfolio_securities` persists each holding’s EUR `purchase_value` as cents in `portfolio_securities`, and `get_portfolio_positions` converts that stored cent total to EUR via `_resolve_average_cost_totals` before returning it in the payload. |
| `positions[].average_cost.primary.value` | number | “Ø Kaufpreis” primary line | Average price per unit in the security currency. Shares the same dataset as the security snapshot average cost. | 4. Calculate and stored inside the database. | `db_calculate_sec_purchase_value` computes the security-currency purchase totals, the price cycle writes those totals into `portfolio_securities`, and `get_portfolio_positions` derives `average_cost["security"]` by dividing the stored `security_currency_total` by `total_holdings`. |
| `positions[].average_cost.primary.currency` | string (ISO 4217) | “Ø Kaufpreis” primary line | Currency code for the primary average price. | 1. passed from portfolio file and stored in database | The same `PSecurity.currencyCode` persisted on `securities.currency_code` should label these averages, but `AverageCostSelection`/`get_portfolio_positions` only emit numeric slots with no currency tag today, so we should extend the average_cost payload to include the stored code. |
| `positions[].average_cost.secondary.value` | number (EUR, optional) | “Ø Kaufpreis” secondary line | Average price converted from the primary value into EUR by applying the backend FX translation. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_resolve_average_cost_totals` builds an `AverageCostSelection` whose `eur` slot divides the EUR purchase totals by the share count, and `_normalize_portfolio_positions` serialises that dataclass straight into the outgoing `average_cost` map. 【F:custom_components/pp_reader/data/db_access.py†L808-L924】【F:custom_components/pp_reader/data/aggregations.py†L201-L295】 |
| `positions[].average_cost.secondary.currency` | string (`"EUR"`, optional) | “Ø Kaufpreis” secondary line | Always `EUR`; matches the converted secondary average price. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: the positions query and serializer emit only the numeric `AverageCostSelection` fields (including `eur`) without a currency tag, so we still need to label the secondary slot as `"EUR"` before responding. 【F:custom_components/pp_reader/data/db_access.py†L836-L924】 |
| `positions[].average_cost.fx_rate_timestamp` | ISO 8601 datetime string (nullable) | Tooltip FX timestamp | Timestamp of the FX rate supporting the converted average price. | 3. Frankfurt, APIFX fetch store and database. | Portfolio purchase aggregation `db_calculate_sec_purchase_value` gathers FX requirements, invokes `ensure_exchange_rates_for_dates_sync`, and `_determine_exchange_rate` pulls rates via `load_latest_rates_sync` from `fx_rates`; add a follow-up to persist that rate date on the `AverageCostSelection` payload for this timestamp. |
| `positions[].security_currency_code` | string (ISO 4217) | Currency badges | Trading currency for the security, reused in tooltips and formatting. | 1. passed from portfolio file and stored in database | Portfolio proto exposes `PSecurity.currencyCode` (string) and `_sync_securities` writes it to `securities.currency_code`, but `get_portfolio_positions` never selects or returns that column yet, so we need a follow-up to forward the stored currency with each position. |
| `positions[].performance.gain_eur` | number (EUR) | Gain column (absolute) | Direct gain metric delivered by the backend. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `get_portfolio_positions` feeds the EUR purchase/current totals into `select_performance_metrics`, and `_normalize_portfolio_positions` forwards the resulting `performance.gain_abs` field unchanged to websocket clients.【F:custom_components/pp_reader/data/db_access.py†L904-L934】【F:custom_components/pp_reader/data/performance.py†L83-L150】【F:custom_components/pp_reader/data/websocket.py†L360-L404】 |
| `positions[].performance.gain_pct` | number (%) | Gain column (percentage) | Percentage gain supplied without frontend calculations. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | The same metrics helper returns `gain_pct` beside `gain_abs`, and the websocket normaliser copies the `performance` mapping straight into the payload, so the frontend receives the precomputed percentage.【F:custom_components/pp_reader/data/db_access.py†L904-L934】【F:custom_components/pp_reader/data/performance.py†L83-L150】【F:custom_components/pp_reader/data/websocket.py†L360-L404】 |
| `positions[].performance.day_change.value_native` | number | Tagesänderung tooltip & delta badges | Day price delta mirrored from the security snapshot for quick comparison. | 4. Calculate and stored inside the database. | `get_portfolio_positions` joins `securities.day_change_native` so each row forwards the persisted native delta without recomputing, letting the overview table show the same change used in the detail view. |
| `positions[].performance.day_change.value_eur` | number (optional) | Tagesänderung tooltip & delta badges | EUR-denominated day price change aligned with the dashboard summary. | 4. Calculate and stored inside the database. | The loader reuses `securities.day_change_eur` for the EUR delta, ensuring the positions table and security snapshot surface identical EUR movements based on the stored FX translation. |
| `positions[].valuation_state.status` | enum (`complete`, `partial`, `missing`) | Warning icons & dataset metadata | Backend evaluation of valuation completeness for the holding. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: the positions payload assembled in `get_portfolio_positions`/`_normalize_portfolio_positions` lacks any valuation keys today, so we still need to derive and attach the enum before responding.【F:custom_components/pp_reader/data/db_access.py†L904-L934】【F:custom_components/pp_reader/data/websocket.py†L360-L404】 |
| `positions[].valuation_state.reason` | string (optional) | Warning tooltip | Optional explanation for non-`complete` statuses. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: `get_portfolio_positions` and `_normalize_portfolio_positions` only return holdings, pricing, and performance fields today, so we still need to derive valuation flags (e.g., missing market prices) and attach the explanatory reason when building the websocket payload. 【F:custom_components/pp_reader/data/db_access.py†L733-L923】【F:custom_components/pp_reader/data/websocket.py†L312-L399】 |
| `positions[].data_state.status` | enum (`ok`, `error`) | Inline error banner | Declares whether the backend detected an error while assembling the positions payload. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: `ws_get_portfolio_positions` still returns a top-level `error` string on missing portfolios or loader failures, so we need to map those outcomes into per-position `data_state.status` values before emitting the payload. 【F:custom_components/pp_reader/data/websocket.py†L1004-L1069】 |
| `positions[].data_state.message` | string (optional) | Inline error banner | Human-readable error message shown when `status` is `error`. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: the websocket handler only surfaces failure text via the response-level `error` field today, so the normalization step must copy that string into each position’s `data_state.message` when `status` is `error`. 【F:custom_components/pp_reader/data/websocket.py†L1004-L1069】 |

## Last file update (snapshot slice of `pp_reader/get_dashboard_data`; live updates via `last_file_update` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `last_file_update` | ISO 8601 datetime string | Footer card metadata & header fallback | Timestamp of the most recent portfolio import processed by the backend. The push payload and snapshot share the same formatted string. | 4. Calculate and stored inside the database. | `_SyncRunner._store_last_file_update` upserts the truncated ISO timestamp into `metadata('last_file_update')`, `_emit_last_file_update` formats it with the Europe/Berlin timezone, and `ws_get_dashboard_data` mirrors the same value for snapshot consumers.【F:custom_components/pp_reader/data/sync_from_pclient.py†L1394-L1430】【F:custom_components/pp_reader/data/websocket.py†L556-L607】 |

## Security snapshot (`pp_reader/get_security_snapshot` command, `security_snapshot` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `security_id` | string (UUID) | Detail tab routing & shared dataset keys | Canonical identifier tying the snapshot to the selected security. | 1. passed from portfolio file and stored in database | Portfolio file passes `PSecurity.uuid`, `_sync_securities` writes it into `securities.uuid`, and the snapshot lookup queries by that UUID. |
| `snapshot_timestamp` | ISO 8601 datetime string | Header metadata | Timestamp representing when the snapshot values were recorded. | 4. Calculate and stored inside the database. | `get_security_snapshot` and `_serialise_security_snapshot` return holdings and pricing data but never include a timestamp yet, so we need a follow-up to persist the snapshot instant (e.g. reuse `metadata.last_file_update`) and expose it with the payload. |
| `name` | string | Detail header title | Security display name shown in the detail view. | 1. passed from portfolio file and stored in database | `PSecurity.name` persists into `securities.name` via `_sync_securities`, and `get_security_snapshot` surfaces the stored value. |
| `currency_code` | string (ISO 4217) | Header metadata & chart legend | Trading currency for all price figures. | 1. passed from portfolio file and stored in database | `PSecurity.currencyCode` flows into `securities.currency_code` through `_sync_securities`, which `get_security_snapshot` reads for the snapshot currency. |
| `account_currency_code` | string (ISO 4217, optional) | FX tooltip | Account currency associated with the position when different from the security currency. | 1. passed from portfolio file and stored in database | Portfolio proto supplies `PPortfolio.referenceAccount` and the linked `PAccount.currencyCode` strings, which `_sync_portfolios` and `_sync_accounts` persist into `portfolios.reference_account` and `accounts.currency_code` so the snapshot can read the holder’s account currency. |
| `holdings.total_units` | number | Header “Bestand” block | Total units owned according to the latest snapshot. | 4. Calculate and stored inside the database. | `_sync_portfolio_securities` persists each `(portfolio, security)` `current_holdings` computed by `db_calculate_current_holdings`, and `get_security_snapshot` sums those stored rows via `compute_holdings_aggregation` to deliver the precomputed total. |
| `holdings.precise_units` | number (optional) | Header “Bestand” block tooltip | High-precision units when available. | 4. Calculate and stored inside the database. | `get_security_snapshot` only returns the rounded `total_holdings`, so we still need to surface the raw `portfolio_securities.current_holdings` (stored in 10⁻⁸ units per `data/db_schema.py`) as a dedicated precise value. |
| `last_price.native_value` | number | “Letzter Preis” block & chart stitching | Latest trade price delivered already scaled in the security currency. | 2. Yahoo query life fetch store in database. | Yahoo’s `20251011_AAPL_full_set.md` sample exposes `regularMarketPrice`, `YahooQueryProvider.fetch` copies that field into each `Quote`, and `_run_price_cycle` hands the scaled value to `_apply_price_updates`, which writes `securities.last_price`. |
| `last_price.account_value` | number (optional) | “Letzter Preis” secondary display | Converted last price supplied when available (EUR/account currency). | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: `get_security_snapshot` already converts the stored cent quote to EUR via `normalize_price_to_eur_sync` and `_serialise_security_snapshot` emits it as `last_price_eur`, but we still need to surface that figure under the documented `last_price.account_value` key. 【F:custom_components/pp_reader/data/db_access.py†L521-L660】【F:custom_components/pp_reader/data/websocket.py†L148-L205】 |
| `last_price.market_time` | ISO 8601 datetime string | “Letzter Preis” block subtitle | Market timestamp associated with the latest price, displayed alongside the quote in the detail header. | 2. Yahoo query life fetch store in database. | `_apply_price_updates` persists Yahoo quote timestamps into `securities.last_price_time`; the snapshot forwards that string so the UI can render the precise market instant next to `last_price.native_value`. |
| `last_price.fetched_at` | ISO 8601 datetime string | Detail footer freshness row | Timestamp when the backend fetched the latest price batch. | 2. Yahoo query life fetch store in database. | `_run_price_cycle` derives `_utc_now_iso()` for each Yahoo batch and passes it into `_apply_price_updates`, which persists the stamp in `securities.last_price_fetched_at`; the snapshot surfaces it for display in the security detail footer. |
| `market_value_eur` | number (EUR) | “Marktwert (EUR)” block | Market value expressed in EUR. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `get_security_snapshot` multiplies the aggregated holdings by the converted EUR last price to derive `market_value_eur`, and `_serialise_security_snapshot` rounds and returns that number in the websocket payload. 【F:custom_components/pp_reader/data/db_access.py†L532-L660】【F:custom_components/pp_reader/data/websocket.py†L148-L196】 |
| `purchase_value_eur` | number (EUR) | FX tooltip context | Total purchase value in EUR used for gain calculations. | 4. Calculate and stored inside the database. | `_sync_portfolio_securities` writes each holding’s EUR `purchase_value` cents into SQLite, `compute_holdings_aggregation` converts those cents via `cent_to_eur`, and `get_security_snapshot` returns the aggregated EUR total in the payload. |
| `average_cost.primary.value` | number | Average purchase card primary line | Shares the same backend dataset as `positions[].average_cost.primary.value`. | 4. Calculate and stored inside the database. | `db_calculate_sec_purchase_value` computes the security-currency totals and averages, `_run_price_cycle` upserts them into `portfolio_securities.security_currency_total`, and `select_average_cost`/`_resolve_average_cost_totals` in `get_security_snapshot` emit that average as the primary value. |
| `average_cost.primary.currency` | string (ISO 4217) | Average purchase card primary line | Currency code for the primary average purchase price. | 1. passed from portfolio file and stored in database | The portfolio file exposes `PSecurity.currencyCode` (string), and `_sync_securities` writes it into `securities.currency_code`, which `get_security_snapshot` selects for the primary average-cost currency. |
| `average_cost.secondary.value` | number (EUR, optional) | Average purchase card secondary line | Average price converted from the primary value into EUR by applying the backend FX translation. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_resolve_average_cost_totals` calls `select_average_cost`, which divides the EUR purchase totals by the share counts to populate `selection.eur`, and `get_security_snapshot` with `_serialise_security_snapshot` forwards that dataclass so the websocket payload already includes the converted average price.【F:custom_components/pp_reader/data/aggregations.py†L176-L260】【F:custom_components/pp_reader/data/db_access.py†L574-L666】【F:custom_components/pp_reader/data/websocket.py†L186-L205】 |
| `average_cost.secondary.currency` | string (`"EUR"`, optional) | Average purchase card secondary line | Always `EUR`; matches the converted secondary average price. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `AverageCostSelection` only exposes numeric fields (`native`, `security`, `account`, `eur`) and `_serialise_security_snapshot` emits that mapping unchanged, so we still need to add an explicit `"EUR"` currency string alongside the secondary value before the frontend can display it.【F:custom_components/pp_reader/data/aggregations.py†L49-L69】【F:custom_components/pp_reader/data/websocket.py†L197-L205】 |
| `average_cost.fx_rate_timestamp` | ISO 8601 datetime string (nullable) | Tooltip FX timestamp | Timestamp of the FX rate supporting the converted average price. | 3. Frankfurt, APIFX fetch store and database. | `get_security_snapshot` reads the aggregated purchase metrics produced by `db_calculate_sec_purchase_value`, so once that flow’s Frankfurter fetch (`ensure_exchange_rates_for_dates_sync` + `load_latest_rates_sync` on `fx_rates`) exposes its rate date we can emit it with the snapshot averages. |
| `performance.total.gain_eur` | number (EUR) | Total gain tile | Total gain provided by backend calculations. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `select_performance_metrics` computes `gain_abs` from the EUR market and purchase totals and mirrors it into `total_change_eur`, and `get_security_snapshot` serialises that `performance` mapping into the websocket payload, so the frontend receives the precomputed EUR gain value directly.【F:custom_components/pp_reader/data/performance.py†L83-L148】【F:custom_components/pp_reader/data/db_access.py†L631-L667】 |
| `performance.total.gain_pct` | number (%) | Total gain tile | Total gain percentage delivered by the backend. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `select_performance_metrics` computes `gain_pct` (and mirrors it into `total_change_pct`) from the stored market and purchase values, and `get_security_snapshot` serialises that structure into the websocket payload.【F:custom_components/pp_reader/data/performance.py†L83-L161】【F:custom_components/pp_reader/data/db_access.py†L631-L667】 |
| `performance.day_change.value_native` | number | “Tagesänderung” block | Day price change in the security currency. | 4. Calculate and stored inside the database. | The price cycle compares `securities.last_price` against the most recent `historical_prices.close` for the same security and persists the delta in `securities.day_change_native`, which the snapshot exposes unchanged. |
| `performance.day_change.value_eur` | number (optional) | “Tagesänderung” block | Day price change converted to EUR. | 4. Calculate and stored inside the database. | After computing the native delta the backend multiplies it by the freshest Frankfurter FX rate (when present) and stores the result in `securities.day_change_eur`; the snapshot reuses that persisted EUR change. |
| `performance.day_change.pct` | number (%) | “Tagesänderung” block | Day percentage change persisted by backend. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | The delta stored in `securities.day_change_native` combines with the persisted previous close to derive `change_pct`, which the snapshot serializer forwards after rounding.【F:custom_components/pp_reader/data/performance.py†L131-L159】【F:custom_components/pp_reader/data/db_access.py†L631-L667】 |
| `performance.day_change.coverage_ratio` | number (0–1, optional) | Tooltip | Coverage of the day change data when incomplete. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_coverage_ratio` measures how many native prices were available for the day-change computation, and the snapshot serializer forwards that coverage flag alongside the other metrics in the emitted payload.【F:custom_components/pp_reader/data/performance.py†L48-L61】【F:custom_components/pp_reader/data/performance.py†L137-L159】【F:custom_components/pp_reader/data/db_access.py†L631-L667】 |
| `performance.day_change.source` | enum (`market`, `estimated`, `cached`) | Tooltip | Provenance of the day change values. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `select_performance_metrics` labels the day-change origin (`native`, `eur`, or `unavailable`) based on which inputs were present, and `get_security_snapshot` passes that enum straight through to the websocket payload for display.【F:custom_components/pp_reader/data/performance.py†L137-L159】【F:custom_components/pp_reader/data/db_access.py†L631-L667】 |
| `purchase_totals.security_currency` | number | FX tooltip | Aggregate purchase value in the security currency. | 4. Calculate and stored inside the database. | `db_calculate_sec_purchase_value` totals each holding’s native spend into `security_currency_total`【F:custom_components/pp_reader/logic/securities.py†L520-L538】, `_run_price_cycle` writes those totals into `portfolio_securities.security_currency_total` for every impacted pair【F:custom_components/pp_reader/prices/price_service.py†L538-L666】, and `compute_holdings_aggregation` with `get_security_snapshot` sum the stored column into the emitted `purchase_total_security` value.【F:custom_components/pp_reader/data/aggregations.py†L85-L138】【F:custom_components/pp_reader/data/db_access.py†L643-L651】 |
| `purchase_totals.account_currency` | number (EUR, optional) | FX tooltip | Aggregate purchase value converted to EUR by the backend, regardless of the account currency used at purchase time. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `get_security_snapshot` feeds `_resolve_average_cost_totals` and attaches its `purchase_total_account` to the aggregation map, and `_serialise_security_snapshot` rounds that value so the payload exposes the backend-converted EUR total.【F:custom_components/pp_reader/data/db_access.py†L573-L651】【F:custom_components/pp_reader/data/websocket.py†L260-L266】 |
| `purchase_fx.rate` | number | FX tooltip | Exchange rate used for conversions in the purchase context. | 3. Frankfurt, APIFX fetch store and database. | `custom_components/pp_reader/logic/securities.py::db_calculate_sec_purchase_value` gathers non-EUR transaction dates and calls `ensure_exchange_rates_for_dates_sync`; the Frankfurter client (`currencies/fx.py::_fetch_exchange_rates`) hits `https://api.frankfurter.app/{date}?from=EUR&to={symbols}` and `_save_rates_sync` upserts into the SQLite `fx_rates (date, currency, rate)` table declared in `data/db_schema.py`, then `_determine_exchange_rate` reloads the stored number via `load_latest_rates_sync`, so we just need to expose that persisted value on the snapshot serializer. |
| `purchase_fx.currency_pair` | string | FX tooltip | Currency pair used for the exchange rate. | 3. Frankfurt, APIFX fetch store and database. | Because `_fetch_exchange_rates` always requests `from=EUR`, `_save_rates_sync` records each term currency under `fx_rates.currency`, letting the serializer label the stored rate as `EUR/{tx.currency_code}` once the metadata is forwarded with the snapshot payload. |
| `purchase_fx.as_of` | ISO 8601 datetime string | FX tooltip “Stand” line | Timestamp associated with `purchase_fx.rate`. | 3. Frankfurt, APIFX fetch store and database. | `ensure_exchange_rates_for_dates_sync` iterates every transaction timestamp, formats it via `dt.strftime("%Y-%m-%d")`, and `_save_rates_sync` keeps that string as the `fx_rates.date` primary key, so wiring the saved metadata into the snapshot will surface the persisted rate date. |
| `data_source` | enum (`live`, `cache`, `historic`) | Cached data notice | Indicates whether the snapshot originates from live or cached data. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `get_security_snapshot` and `_serialise_security_snapshot` currently emit only pricing, aggregation, and performance keys, leaving `data_source` unset, so we still need follow-up logic to tag snapshots as live/cache/historic before sending them.【F:custom_components/pp_reader/data/db_access.py†L654-L667】【F:custom_components/pp_reader/data/websocket.py†L240-L292】 |
| `last_transaction_at` | ISO 8601 datetime string (nullable) | Meta section optional row | Timestamp for the most recent trade involving the security. | 4. Calculate and stored inside the database. | The `transactions` table already stores each trade’s ISO `date` for later aggregation【F:custom_components/pp_reader/data/db_schema.py†L126-L148】, but `get_security_snapshot` still returns a payload without `last_transaction_at`, so we need a follow-up to compute and persist the latest transaction timestamp before emitting the snapshot.【F:custom_components/pp_reader/data/db_access.py†L643-L665】 |

## Security history (`pp_reader/get_security_history` command, `security_history` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `security_id` | string (UUID) | History chart container | Identifies which security the series belongs to. | 1. passed from portfolio file and stored in database | Security UUIDs arrive via `PSecurity.uuid`, `_sync_securities` stores them in `securities.uuid`, and the same key is used when persisting `historical_prices.security_uuid` for history queries. |
| `range` | string (`1M`, `3M`, `1Y`, `5Y`, `ALL`, etc.) | Range selector dataset | Confirms which pre-computed window the backend returned. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `ws_get_security_history` already receives `start_date`/`end_date` parameters and echoes them back in the response, so we just need to translate those epoch-day bounds into the canonical range tokens before returning the payload.【F:custom_components/pp_reader/data/websocket.py†L842-L880】【F:tests/test_ws_security_history.py†L331-L467】 |
| `series_source` | enum (`portfolio_performance`, `market_data`) | Chart legend | States where the price series originated. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Portfolio imports write every `security.prices` row into `historical_prices` without tagging the origin, so once the Yahoo history ingest lands we must persist a source flag (e.g. new column or join table) and let the history serializer map it to `portfolio_performance` vs `market_data` for the legend.【F:custom_components/pp_reader/data/db_schema.py†L57-L73】【F:custom_components/pp_reader/data/sync_from_pclient.py†L1090-L1144】 |
| `prices` | array of price points ordered by date | History chart | Time-series data for plotting. | 2. Yahoo query life fetch store in database. | Yahoo’s `history_1y_1d` sample lists the daily OHLC rows we need, but only `sync_from_pclient` currently persists Portfolio Performance `security.prices` into `historical_prices`, so we still owe a Yahoo history ingest to write those series. |
| `prices[].date` | ISO 8601 date string | Chart axis | Daily timestamp of the price point. | 2. Yahoo query life fetch store in database. | Sample history records ship ISO datestamps, yet `iter_security_close_prices` still reads integer days inserted by the portfolio importer, so the Yahoo pipeline must parse and store these dates before the endpoint can serve them. |
| `prices[].close_native` | number | Chart series | Closing price in the security currency. | 2. Yahoo query life fetch store in database. | Yahoo exposes `close` values alongside each date, but the current importer only copies proto closes into `historical_prices.close`, leaving a follow-up to map the Yahoo field into that column. |
| `prices[].close_eur` | number (optional) | EUR overlay & tooltips | Closing price converted to EUR when supplied. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | The history handler already streams native closes from `iter_security_close_prices`, so we need to extend it to call `normalize_price_to_eur_sync` (same helper used for snapshot `last_close_eur`) per row and emit the rounded EUR value alongside the native series.【F:custom_components/pp_reader/data/websocket.py†L811-L880】【F:custom_components/pp_reader/util/currency.py†L114-L176】【F:custom_components/pp_reader/data/db_access.py†L606-L665】【F:tests/test_db_access.py†L893-L939】 |

## Live update envelope (`panels_updated` bus)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `data_type` | enum (`accounts`, `portfolio_values`, `portfolio_positions`, `last_file_update`, `security_snapshot`, `security_history`) | `src/dashboard.ts` event handler | Discriminator instructing the dashboard which handler should process the payload. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_push_update` injects the `data_type` argument verbatim into each event payload, and its callers pass the canonical literals (`"accounts"`, `"portfolio_values"`, `"portfolio_positions"`, etc.), so the frontend receives the correct discriminator for every bus message.【F:custom_components/pp_reader/data/event_push.py†L214-L229】【F:custom_components/pp_reader/data/sync_from_pclient.py†L1424-L1562】【F:custom_components/pp_reader/prices/price_service.py†L1078-L1133】 |
| `payload` | object matching the schemas above | Delegated modules | Dataset delivered to the relevant handler without additional guards. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_compact_event_data` only removes redundant keys before `_push_update` nests the structure under `data`, so the handlers receive the same DB-backed payload objects that the importer or price service fetched prior to emission.【F:custom_components/pp_reader/data/event_push.py†L202-L229】【F:custom_components/pp_reader/data/sync_from_pclient.py†L1462-L1562】【F:custom_components/pp_reader/prices/price_service.py†L1078-L1133】 |
| `synced_at` | ISO 8601 datetime string (optional) | Debug overlay / logs | Timestamp indicating when the backend emitted the event. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_push_update` currently emits only `domain`, `entry_id`, `data_type`, and `data`, so we still need to add a timestamp (for example `dt_util.utcnow().isoformat()`) before the frontend can display `synced_at`.【F:custom_components/pp_reader/data/event_push.py†L224-L229】 |

