# Frontend Canonical Data Model

This document consolidates the future-facing backend payloads required by the Portfolio Performance Reader frontend. Each field listed below must be delivered by the integration API exactly as described so the UI can render without synthesising fallback data or duplicating calculations. Status enums are shared across payloads to avoid divergent interpretations (`complete`, `partial`, `missing`).

**Recommendation:** The six backend data source options below cover the full set of frontend needs; no additional sourcing categories are required.

## Dashboard summary (`pp_reader/get_dashboard_summary` command, `dashboard_summary` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `summary.total_wealth_eur` | number (EUR) | Overview header wealth chip | Combined EUR wealth across all accounts and portfolios, pre-aggregated by the backend. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: `ws_get_dashboard_data` only emits accounts/portfolios without a summary block, so we still need to sum the live SQLite aggregates from `_load_accounts_payload` and `fetch_live_portfolios` before responding. 【F:custom_components/pp_reader/data/websocket.py†L585-L627】【F:custom_components/pp_reader/data/db_access.py†L981-L1018】 |
| `summary.fx_status` | enum (`complete`, `partial`, `missing`) | Overview header warning banner | FX coverage flag controlling the warning banner across the dashboard. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: the same websocket handler currently returns no FX status, so we must derive it at send time by inspecting the per-account FX availability flags produced in `_load_accounts_payload`. 【F:custom_components/pp_reader/data/websocket.py†L585-L627】【F:custom_components/pp_reader/data/websocket.py†L38-L112】 |
| `summary.calculated_at` | ISO 8601 datetime string | Header metadata + footer fallback | Timestamp when the backend produced the summary payload. Replaces both the previous totals timestamp and summary sync timestamp fields. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: we still need to stamp the summary payload with `datetime.now()` (UTC) when assembling the websocket result, because the existing handler forwards only the account/portfolio data without a produced-at timestamp. 【F:custom_components/pp_reader/data/websocket.py†L585-L627】 |

## Account summaries (`pp_reader/get_accounts` command, `accounts` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `accounts` | array of account objects | Overview liquidity tables | Ordered list of all investment and cash accounts displayed in the overview. | 1. passed from portfolio file and stored in database | Portfolio file streams repeated `PAccount` entries through `PClient.accounts`, and `_sync_accounts` upserts each payload into the SQLite `accounts` table for API reads. |
| `accounts[].account_id` | string (UUID) | Liquidity tables row keys & push update matching | Stable identifier matching the backend `accounts` table primary key. | 1. passed from portfolio file and stored in database | `_sync_accounts` writes `PAccount.uuid` into `accounts.uuid`, keeping the proto account identifier as the database primary key. |
| `accounts[].name` | string | Liquidity tables | Human-readable account name rendered verbatim. | 1. passed from portfolio file and stored in database | The importer maps `PAccount.name` directly into `accounts.name`, so the UI receives the exact label supplied by the portfolio file. |
| `accounts[].currency_code` | string (ISO 4217) | EUR/FX grouping headers & currency badges | Currency associated with the account. | 1. passed from portfolio file and stored in database | Proto `PAccount.currencyCode` is a string field and `_sync_accounts` writes it into the SQLite `accounts.currency_code` column so the frontend sees the original code. |
| `accounts[].balance_native` | number (account currency, nullable) | FX account table | Account balance expressed in the original account currency; nullable for EUR-only accounts. | 1. passed from portfolio file and stored in database | Portfolio exports do not carry an account balance field, and `_sync_accounts` currently recomputes `accounts.balance` via `db_calc_account_balance`; need follow-up to align the data source with this documentation. |
| `accounts[].balance_eur` | number (EUR) | EUR account table, totals calculations | Canonical EUR valuation for the account supplied directly by the backend. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_load_accounts_payload` pulls each stored cent balance via `get_accounts`, ensures today's Frankfurter rates, and divides the native amount by the loaded rate before returning the websocket `balance` field. 【F:custom_components/pp_reader/data/db_access.py†L399-L408】【F:custom_components/pp_reader/data/websocket.py†L80-L128】 |
| `accounts[].fx_rate_updated_at` | ISO 8601 datetime string (nullable) | FX tooltips | Timestamp of the FX rate used to derive `balance_eur`. | 3. Frankfurt, APIFX fetch store and database. | `_load_accounts_payload` preloads today's FX via `ensure_exchange_rates_for_dates`/`load_latest_rates`, and `currencies.fx` fetches `https://api.frankfurter.app/{date}` then `_save_rates_sync` upserts into the `fx_rates` table; we still need to surface that stored date as `fx_rate_updated_at`. |
| `accounts[].fx_status` | enum (`complete`, `partial`, `missing`) | Account-level warning badges and banner aggregation | FX health indicator for the specific account, sharing the same backing dataset as the dashboard summary status. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: the websocket layer only emits the boolean `fx_unavailable` flag when a rate is missing, so we still need to map that status into the documented enum before responding. 【F:custom_components/pp_reader/data/websocket.py†L97-L126】 |

## Portfolio summaries (`pp_reader/get_portfolios` command, `portfolio_values` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `portfolios` | array of portfolio summary objects | Portfolio overview table | Collection of portfolio aggregates aligned with the frontend ordering. | 1. passed from portfolio file and stored in database | Repeated `PPortfolio` entries from `PClient.portfolios` are inserted by `_sync_portfolios` into the `portfolios` table, preserving the order for API reads. |
| `portfolios[].portfolio_id` | string (UUID) | Portfolio table row keys & push update matching | Primary key matching the backend `portfolios` table. | 1. passed from portfolio file and stored in database | `PPortfolio.uuid` (string) arrives via the portfolio file and `_sync_portfolios` writes it directly into `portfolios.uuid`, so the frontend keys rows off the persisted proto identifier. |
| `portfolios[].name` | string | Portfolio table first column | Portfolio display name shown in the overview. | 1. passed from portfolio file and stored in database | `_sync_portfolios` copies `PPortfolio.name` into the SQLite `portfolios.name` column, ensuring the UI renders the exact label from the import. |
| `portfolios[].position_count` | integer | “Anzahl Positionen” column | Persisted count of active positions. | 4. Calculate and stored inside the database. | `_sync_portfolio_securities` persists each holding's `current_holdings` in `portfolio_securities`, and `fetch_live_portfolios` returns `COUNT(CASE WHEN ps.current_holdings > 0 THEN 1 END)` so SQLite hands the pre-counted total to the API. |
| `portfolios[].current_value_eur` | number (EUR) | “Aktueller Wert” column & totals | Current market value already converted to EUR. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `fetch_live_portfolios` sums `portfolio_securities.current_value` cents, `_normalize_portfolio_row` converts the aggregate to EUR, and `_live_portfolios_payload` forwards that `current_value` straight to websocket clients. 【F:custom_components/pp_reader/data/db_access.py†L940-L1040】【F:custom_components/pp_reader/data/websocket.py†L476-L524】 |
| `portfolios[].purchase_value_eur` | number (EUR) | Hidden totals dataset | Total invested capital in EUR used for performance calculations. | 4. Calculate and stored inside the database. | `_sync_portfolio_securities` stores aggregated `purchase_value` cents per holding, `fetch_live_portfolios` sums `ps.purchase_value`, and `_normalize_portfolio_row` converts that cent total to EUR for the payload. |
| `portfolios[].performance.gain_eur` | number (EUR) | Gain column (absolute) | Absolute gain supplied directly by backend calculations. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_normalize_portfolio_row` sums the cent totals, runs `select_performance_metrics`, and serialises the resulting `PerformanceMetrics.gain_abs`, which `_live_portfolios_payload` returns unchanged in the websocket payload. 【F:custom_components/pp_reader/data/db_access.py†L950-L1041】【F:custom_components/pp_reader/data/performance.py†L60-L150】【F:custom_components/pp_reader/data/websocket.py†L514-L523】 |
| `portfolios[].performance.gain_pct` | number (%) | Gain column (percentage) | Percentage gain derived by backend logic. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | The same helper computes `PerformanceMetrics.gain_pct` from the aggregated purchase/current sums and the websocket normaliser forwards the nested `performance` dict to clients. 【F:custom_components/pp_reader/data/db_access.py†L950-L1041】【F:custom_components/pp_reader/data/performance.py†L60-L150】【F:custom_components/pp_reader/data/websocket.py†L514-L523】 |
| `portfolios[].valuation_state.status` | enum (`complete`, `partial`, `missing`) | Warning badge + totals guard | Backend evaluation of valuation completeness (covers FX and missing prices). | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: the portfolio query only exposes `missing_value_positions`/`has_current_value`, so we still need to map those flags into the documented enum before the websocket responds. 【F:custom_components/pp_reader/data/db_access.py†L950-L1041】【F:custom_components/pp_reader/data/websocket.py†L514-L547】 |
| `portfolios[].valuation_state.missing_positions` | integer (optional) | Tooltip / badge copy | Count of holdings lacking valuation data when `status` is `partial` or `missing`. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `fetch_live_portfolios` aggregates NULL-valued holdings into `missing_value_positions`, `_normalize_portfolio_row` keeps the count on each entry, and `_live_portfolios_payload` / `_normalize_portfolio_value_entry` forward it unchanged in websocket and event payloads. 【F:custom_components/pp_reader/data/db_access.py†L950-L1041】【F:custom_components/pp_reader/data/websocket.py†L476-L524】【F:custom_components/pp_reader/data/event_push.py†L44-L90】 |

## Portfolio positions (`pp_reader/get_portfolio_positions` command, `portfolio_positions` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `portfolio_id` | string (UUID) | Expandable table container | Identifies which portfolio the enclosed positions belong to. | 1. passed from portfolio file and stored in database | Portfolio uploads stream `PPortfolio.uuid` strings inside `PClient.portfolios`, `_sync_portfolios` upserts each UUID into `portfolios.uuid`, and the `ws_get_portfolio_positions` response echoes the same value as `portfolio_uuid` for the frontend container. |
| `positions` | array of position objects | Positions detail tables | Ordered holdings for the selected portfolio. | 1. passed from portfolio file and stored in database | Portfolio transactions carry the `PTransaction.portfolio`/`security` strings, `_sync_transactions` persists them into `transactions.portfolio` and `.security`, `_sync_portfolio_securities` aggregates those records into `portfolio_securities`, and `get_portfolio_positions` returns that table as the `positions` list. |
| `positions[].position_id` | string (UUID) | Row dataset attributes & diffing | Stable identifier for the position row within the portfolio. | 4. Calculate and stored inside the database. | `get_portfolio_positions` still emits rows keyed by `security_uuid` without generating a separate `position_id`, so we need a follow-up to persist and expose a dedicated identifier. |
| `positions[].portfolio_id` | string (UUID) | Push reconciliation | Portfolio identifier repeated for differential updates. | 1. passed from portfolio file and stored in database | `PPortfolio.uuid` arrives as a string, `_sync_portfolios` upserts it into `portfolios.uuid`, and both `get_portfolio_positions` and the websocket response filter and emit rows by that stored UUID for each positions payload. |
| `positions[].security_id` | string (UUID) | Row dataset attributes & detail navigation | Security identifier used to open the detail tab. | 1. passed from portfolio file and stored in database | `PSecurity.uuid` is persisted via `_sync_securities` into `securities.uuid`, and `get_portfolio_positions` selects the matching `ps.security_uuid` so each position keeps the proto-provided key. |
| `positions[].name` | string | Positions table first column | Security label rendered verbatim. | 1. passed from portfolio file and stored in database | `PSecurity.name` is written to `securities.name` inside `_sync_securities`, and `get_portfolio_positions` joins that column (`s.name`) to populate the display label. |
| `positions[].quantity` | number (supports fractional) | “Bestand” column | Persisted holdings amount with backend precision. | 4. Calculate and stored inside the database. | `db_calculate_current_holdings` collapses transactions into share totals per `(portfolio, security)` pair, `_sync_portfolio_securities` writes those `current_holdings` into SQLite, and `get_portfolio_positions` feeds the stored value through `compute_holdings_aggregation` so the response emits the precomputed quantity. |
| `positions[].current_value_eur` | number (EUR) | “Aktueller Wert” column & totals | EUR market value supplied directly by the backend. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `get_portfolio_positions` converts the stored `portfolio_securities.current_value` cents to EUR before returning `current_value`, and `_normalize_portfolio_positions` only rounds and forwards that field to websocket clients. 【F:custom_components/pp_reader/data/db_access.py†L904-L924】【F:custom_components/pp_reader/data/websocket.py†L384-L401】 |
| `positions[].purchase_value_eur` | number (EUR) | Hidden dataset & FX tooltip | Aggregate purchase cost per holding for gain and disclosure logic. | 4. Calculate and stored inside the database. | `_sync_portfolio_securities` persists each holding’s EUR `purchase_value` as cents in `portfolio_securities`, and `get_portfolio_positions` converts that stored cent total to EUR via `_resolve_average_cost_totals` before returning it in the payload. |
| `positions[].average_cost.primary.value` | number | “Ø Kaufpreis” primary line | Average price per unit in the security currency. Shares the same dataset as the security snapshot average cost. | 4. Calculate and stored inside the database. | `db_calculate_sec_purchase_value` computes the security-currency purchase totals, the price cycle writes those totals into `portfolio_securities`, and `get_portfolio_positions` derives `average_cost["security"]` by dividing the stored `security_currency_total` by `total_holdings`. |
| `positions[].average_cost.primary.currency` | string (ISO 4217) | “Ø Kaufpreis” primary line | Currency code for the primary average price. | 1. passed from portfolio file and stored in database | The same `PSecurity.currencyCode` persisted on `securities.currency_code` should label these averages, but `AverageCostSelection`/`get_portfolio_positions` only emit numeric slots with no currency tag today, so we should extend the average_cost payload to include the stored code. |
| `positions[].average_cost.secondary.value` | number (EUR, optional) | “Ø Kaufpreis” secondary line | Average price converted from the primary value into EUR by applying the backend FX translation. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_resolve_average_cost_totals` builds an `AverageCostSelection` whose `eur` slot divides the EUR purchase totals by the share count, and `_normalize_portfolio_positions` serialises that dataclass straight into the outgoing `average_cost` map. 【F:custom_components/pp_reader/data/db_access.py†L808-L924】【F:custom_components/pp_reader/data/aggregations.py†L201-L295】 |
| `positions[].average_cost.secondary.currency` | string (`"EUR"`, optional) | “Ø Kaufpreis” secondary line | Always `EUR`; matches the converted secondary average price. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: the positions query and serializer emit only the numeric `AverageCostSelection` fields (including `eur`) without a currency tag, so we still need to label the secondary slot as `"EUR"` before responding. 【F:custom_components/pp_reader/data/db_access.py†L836-L924】 |
| `positions[].average_cost.fx_rate_timestamp` | ISO 8601 datetime string (nullable) | Tooltip FX timestamp | Timestamp of the FX rate supporting the converted average price. | 3. Frankfurt, APIFX fetch store and database. | Portfolio purchase aggregation `db_calculate_sec_purchase_value` gathers FX requirements, invokes `ensure_exchange_rates_for_dates_sync`, and `_determine_exchange_rate` pulls rates via `load_latest_rates_sync` from `fx_rates`; add a follow-up to persist that rate date on the `AverageCostSelection` payload for this timestamp. |
| `positions[].security_currency_code` | string (ISO 4217) | Currency badges | Trading currency for the security, reused in tooltips and formatting. | 1. passed from portfolio file and stored in database | Portfolio proto exposes `PSecurity.currencyCode` (string) and `_sync_securities` writes it to `securities.currency_code`, but `get_portfolio_positions` never selects or returns that column yet, so we need a follow-up to forward the stored currency with each position. |
| `positions[].performance.gain_eur` | number (EUR) | Gain column (absolute) | Direct gain metric delivered by the backend. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `get_portfolio_positions` feeds the EUR purchase/current totals into `select_performance_metrics`, and `_normalize_portfolio_positions` forwards the resulting `performance.gain_abs` field unchanged to websocket clients.【F:custom_components/pp_reader/data/db_access.py†L904-L934】【F:custom_components/pp_reader/data/performance.py†L83-L150】【F:custom_components/pp_reader/data/websocket.py†L360-L404】 |
| `positions[].performance.gain_pct` | number (%) | Gain column (percentage) | Percentage gain supplied without frontend calculations. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | The same metrics helper returns `gain_pct` beside `gain_abs`, and the websocket normaliser copies the `performance` mapping straight into the payload, so the frontend receives the precomputed percentage.【F:custom_components/pp_reader/data/db_access.py†L904-L934】【F:custom_components/pp_reader/data/performance.py†L83-L150】【F:custom_components/pp_reader/data/websocket.py†L360-L404】 |
| `positions[].valuation_state.status` | enum (`complete`, `partial`, `missing`) | Warning icons & dataset metadata | Backend evaluation of valuation completeness for the holding. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: the positions payload assembled in `get_portfolio_positions`/`_normalize_portfolio_positions` lacks any valuation keys today, so we still need to derive and attach the enum before responding.【F:custom_components/pp_reader/data/db_access.py†L904-L934】【F:custom_components/pp_reader/data/websocket.py†L360-L404】 |
| `positions[].valuation_state.reason` | string (optional) | Warning tooltip | Optional explanation for non-`complete` statuses. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: `get_portfolio_positions` and `_normalize_portfolio_positions` only return holdings, pricing, and performance fields today, so we still need to derive valuation flags (e.g., missing market prices) and attach the explanatory reason when building the websocket payload. 【F:custom_components/pp_reader/data/db_access.py†L733-L923】【F:custom_components/pp_reader/data/websocket.py†L312-L399】 |
| `positions[].data_state.status` | enum (`ok`, `error`) | Inline error banner | Declares whether the backend detected an error while assembling the positions payload. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: `ws_get_portfolio_positions` still returns a top-level `error` string on missing portfolios or loader failures, so we need to map those outcomes into per-position `data_state.status` values before emitting the payload. 【F:custom_components/pp_reader/data/websocket.py†L1004-L1069】 |
| `positions[].data_state.message` | string (optional) | Inline error banner | Human-readable error message shown when `status` is `error`. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: the websocket handler only surfaces failure text via the response-level `error` field today, so the normalization step must copy that string into each position’s `data_state.message` when `status` is `error`. 【F:custom_components/pp_reader/data/websocket.py†L1004-L1069】 |

## Last file update (`pp_reader/get_last_file_update` command, `last_file_update` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `last_file_update.ingested_at` | ISO 8601 datetime string | Footer card metadata & header fallback | Timestamp of the most recent portfolio import processed by the backend. Consolidates prior duplicate timestamp fields. | 4. Calculate and stored inside the database. | `_SyncRunner._store_last_file_update` upserts the truncated ISO timestamp into `metadata('last_file_update')`, and `get_last_file_update` reads that row for the websocket payload so the DB holds the ingested time. |
| `last_file_update.source` | string (e.g. `"portfolio_performance"`) | Footer caption | Identifies the origin of the imported data for user messaging. | 1. passed from portfolio file and stored in database | Metadata sync today only upserts the ISO timestamp into the two-column `metadata` table and the websocket handler formats that string, so we still need to extend the schema/command pipeline to persist and emit the source flag alongside it. |

## Security snapshot (`pp_reader/get_security_snapshot` command, `security_snapshot` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `security_id` | string (UUID) | Detail tab routing & shared dataset keys | Canonical identifier tying the snapshot to the selected security. | 1. passed from portfolio file and stored in database | Portfolio file passes `PSecurity.uuid`, `_sync_securities` writes it into `securities.uuid`, and the snapshot lookup queries by that UUID. |
| `snapshot_timestamp` | ISO 8601 datetime string | Header metadata | Timestamp representing when the snapshot values were recorded. | 4. Calculate and stored inside the database. | `get_security_snapshot` and `_serialise_security_snapshot` return holdings and pricing data but never include a timestamp yet, so we need a follow-up to persist the snapshot instant (e.g. reuse `metadata.last_file_update`) and expose it with the payload. |
| `name` | string | Detail header title | Security display name shown in the detail view. | 1. passed from portfolio file and stored in database | `PSecurity.name` persists into `securities.name` via `_sync_securities`, and `get_security_snapshot` surfaces the stored value. |
| `currency_code` | string (ISO 4217) | Header metadata & chart legend | Trading currency for all price figures. | 1. passed from portfolio file and stored in database | `PSecurity.currencyCode` flows into `securities.currency_code` through `_sync_securities`, which `get_security_snapshot` reads for the snapshot currency. |
| `account_currency_code` | string (ISO 4217, optional) | FX tooltip | Account currency associated with the position when different from the security currency. | 1. passed from portfolio file and stored in database | Portfolio proto supplies `PPortfolio.referenceAccount` and the linked `PAccount.currencyCode` strings, which `_sync_portfolios` and `_sync_accounts` persist into `portfolios.reference_account` and `accounts.currency_code` so the snapshot can read the holder’s account currency. |
| `holdings.total_units` | number | Header “Bestand” block | Total units owned according to the latest snapshot. | 4. Calculate and stored inside the database. | `_sync_portfolio_securities` persists each `(portfolio, security)` `current_holdings` computed by `db_calculate_current_holdings`, and `get_security_snapshot` sums those stored rows via `compute_holdings_aggregation` to deliver the precomputed total. |
| `holdings.precise_units` | number (optional) | Header “Bestand” block tooltip | High-precision units when available. | 4. Calculate and stored inside the database. | `get_security_snapshot` only returns the rounded `total_holdings`, so we still need to surface the raw `portfolio_securities.current_holdings` (stored in 10⁻⁸ units per `data/db_schema.py`) as a dedicated precise value. |
| `last_price.native_value` | number | “Letzter Preis” block & chart stitching | Latest trade price delivered already scaled in the security currency. | 2. Yahoo query life fetch store in database. | Yahoo’s `20251011_AAPL_full_set.md` sample exposes `regularMarketPrice`, `YahooQueryProvider.fetch` copies that field into each `Quote`, and `_run_price_cycle` hands the scaled value to `_apply_price_updates`, which writes `securities.last_price`. |
| `last_price.account_value` | number (optional) | “Letzter Preis” secondary display | Converted last price supplied when available (EUR/account currency). | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Follow-up: `get_security_snapshot` already converts the stored cent quote to EUR via `normalize_price_to_eur_sync` and `_serialise_security_snapshot` emits it as `last_price_eur`, but we still need to surface that figure under the documented `last_price.account_value` key. 【F:custom_components/pp_reader/data/db_access.py†L521-L660】【F:custom_components/pp_reader/data/websocket.py†L148-L205】 |
| `last_price.fetched_at` | ISO 8601 datetime string | Price freshness tooltip | Timestamp of the latest market price. | 2. Yahoo query life fetch store in database. | `_run_price_cycle` derives `_utc_now_iso()` for each Yahoo batch and passes it into `_apply_price_updates`, which persists the stamp in `securities.last_price_fetched_at` beside the quote. |
| `market_value_eur` | number (EUR) | “Marktwert (EUR)” block | Market value expressed in EUR. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `get_security_snapshot` multiplies the aggregated holdings by the converted EUR last price to derive `market_value_eur`, and `_serialise_security_snapshot` rounds and returns that number in the websocket payload. 【F:custom_components/pp_reader/data/db_access.py†L532-L660】【F:custom_components/pp_reader/data/websocket.py†L148-L196】 |
| `purchase_value_eur` | number (EUR) | FX tooltip context | Total purchase value in EUR used for gain calculations. | 4. Calculate and stored inside the database. | `_sync_portfolio_securities` writes each holding’s EUR `purchase_value` cents into SQLite, `compute_holdings_aggregation` converts those cents via `cent_to_eur`, and `get_security_snapshot` returns the aggregated EUR total in the payload. |
| `average_cost.primary.value` | number | Average purchase card primary line | Shares the same backend dataset as `positions[].average_cost.primary.value`. | 4. Calculate and stored inside the database. | `db_calculate_sec_purchase_value` computes the security-currency totals and averages, `_run_price_cycle` upserts them into `portfolio_securities.security_currency_total`, and `select_average_cost`/`_resolve_average_cost_totals` in `get_security_snapshot` emit that average as the primary value. |
| `average_cost.primary.currency` | string (ISO 4217) | Average purchase card primary line | Currency code for the primary average purchase price. | 1. passed from portfolio file and stored in database | The portfolio file exposes `PSecurity.currencyCode` (string), and `_sync_securities` writes it into `securities.currency_code`, which `get_security_snapshot` selects for the primary average-cost currency. |
| `average_cost.secondary.value` | number (EUR, optional) | Average purchase card secondary line | Average price converted from the primary value into EUR by applying the backend FX translation. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_resolve_average_cost_totals` calls `select_average_cost`, which divides the EUR purchase totals by the share counts to populate `selection.eur`, and `get_security_snapshot` with `_serialise_security_snapshot` forwards that dataclass so the websocket payload already includes the converted average price.【F:custom_components/pp_reader/data/aggregations.py†L176-L260】【F:custom_components/pp_reader/data/db_access.py†L574-L666】【F:custom_components/pp_reader/data/websocket.py†L186-L205】 |
| `average_cost.secondary.currency` | string (`"EUR"`, optional) | Average purchase card secondary line | Always `EUR`; matches the converted secondary average price. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `AverageCostSelection` only exposes numeric fields (`native`, `security`, `account`, `eur`) and `_serialise_security_snapshot` emits that mapping unchanged, so we still need to add an explicit `"EUR"` currency string alongside the secondary value before the frontend can display it.【F:custom_components/pp_reader/data/aggregations.py†L49-L69】【F:custom_components/pp_reader/data/websocket.py†L197-L205】 |
| `average_cost.fx_rate_timestamp` | ISO 8601 datetime string (nullable) | Tooltip FX timestamp | Timestamp of the FX rate supporting the converted average price. | 3. Frankfurt, APIFX fetch store and database. | `get_security_snapshot` reads the aggregated purchase metrics produced by `db_calculate_sec_purchase_value`, so once that flow’s Frankfurter fetch (`ensure_exchange_rates_for_dates_sync` + `load_latest_rates_sync` on `fx_rates`) exposes its rate date we can emit it with the snapshot averages. |
| `performance.total.gain_eur` | number (EUR) | Total gain tile | Total gain provided by backend calculations. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `select_performance_metrics` computes `gain_abs` from the EUR market and purchase totals and mirrors it into `total_change_eur`, and `get_security_snapshot` serialises that `performance` mapping into the websocket payload, so the frontend receives the precomputed EUR gain value directly.【F:custom_components/pp_reader/data/performance.py†L83-L148】【F:custom_components/pp_reader/data/db_access.py†L631-L667】 |
| `performance.total.gain_pct` | number (%) | Total gain tile | Total gain percentage delivered by the backend. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `select_performance_metrics` computes `gain_pct` (and mirrors it into `total_change_pct`) from the stored market and purchase values, and `get_security_snapshot` serialises that structure into the websocket payload.【F:custom_components/pp_reader/data/performance.py†L83-L161】【F:custom_components/pp_reader/data/db_access.py†L631-L667】 |
| `performance.day_change.value_native` | number | “Tagesänderung” block | Day price change in the security currency. | 2. Yahoo query life fetch store in database. | `get_security_snapshot` normalises the stored Yahoo `last_price` and fetches the latest close via `fetch_previous_close`; `select_performance_metrics` subtracts the values for the native delta, so we still need the Yahoo history ingest to persist the sampled `regularMarketPreviousClose` into `historical_prices`. |
| `performance.day_change.value_eur` | number (optional) | “Tagesänderung” block | Day price change converted to EUR. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `select_performance_metrics` derives the EUR delta by dividing the native change by the detected FX rate and rounding it for the payload, and `get_security_snapshot` serialises that `DayChangeMetrics` structure into the websocket response for the UI.【F:custom_components/pp_reader/data/performance.py†L122-L158】【F:custom_components/pp_reader/data/db_access.py†L606-L667】 |
| `performance.day_change.pct` | number (%) | “Tagesänderung” block | Day percentage change persisted by backend. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | The same helper computes `change_pct` from the native close and price delta, rounding to two decimals before the snapshot API drops the field into the live payload handed to the frontend.【F:custom_components/pp_reader/data/performance.py†L131-L159】【F:custom_components/pp_reader/data/db_access.py†L631-L667】 |
| `performance.day_change.coverage_ratio` | number (0–1, optional) | Tooltip | Coverage of the day change data when incomplete. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_coverage_ratio` measures how many native prices were available for the day-change computation, and the snapshot serializer forwards that coverage flag alongside the other metrics in the emitted payload.【F:custom_components/pp_reader/data/performance.py†L48-L61】【F:custom_components/pp_reader/data/performance.py†L137-L159】【F:custom_components/pp_reader/data/db_access.py†L631-L667】 |
| `performance.day_change.source` | enum (`market`, `estimated`, `cached`) | Tooltip | Provenance of the day change values. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `select_performance_metrics` labels the day-change origin (`native`, `eur`, or `unavailable`) based on which inputs were present, and `get_security_snapshot` passes that enum straight through to the websocket payload for display.【F:custom_components/pp_reader/data/performance.py†L137-L159】【F:custom_components/pp_reader/data/db_access.py†L631-L667】 |
| `purchase_totals.security_currency` | number | FX tooltip | Aggregate purchase value in the security currency. | 4. Calculate and stored inside the database. | `db_calculate_sec_purchase_value` totals each holding’s native spend into `security_currency_total`【F:custom_components/pp_reader/logic/securities.py†L520-L538】, `_run_price_cycle` writes those totals into `portfolio_securities.security_currency_total` for every impacted pair【F:custom_components/pp_reader/prices/price_service.py†L538-L666】, and `compute_holdings_aggregation` with `get_security_snapshot` sum the stored column into the emitted `purchase_total_security` value.【F:custom_components/pp_reader/data/aggregations.py†L85-L138】【F:custom_components/pp_reader/data/db_access.py†L643-L651】 |
| `purchase_totals.account_currency` | number (EUR, optional) | FX tooltip | Aggregate purchase value converted to EUR by the backend, regardless of the account currency used at purchase time. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `get_security_snapshot` feeds `_resolve_average_cost_totals` and attaches its `purchase_total_account` to the aggregation map, and `_serialise_security_snapshot` rounds that value so the payload exposes the backend-converted EUR total.【F:custom_components/pp_reader/data/db_access.py†L573-L651】【F:custom_components/pp_reader/data/websocket.py†L260-L266】 |
| `purchase_fx.rate` | number | FX tooltip | Exchange rate used for conversions in the purchase context. | 3. Frankfurt, APIFX fetch store and database. | `custom_components/pp_reader/logic/securities.py::db_calculate_sec_purchase_value` gathers non-EUR transaction dates and calls `ensure_exchange_rates_for_dates_sync`; the Frankfurter client (`currencies/fx.py::_fetch_exchange_rates`) hits `https://api.frankfurter.app/{date}?from=EUR&to={symbols}` and `_save_rates_sync` upserts into the SQLite `fx_rates (date, currency, rate)` table declared in `data/db_schema.py`, then `_determine_exchange_rate` reloads the stored number via `load_latest_rates_sync`, so we just need to expose that persisted value on the snapshot serializer. |
| `purchase_fx.currency_pair` | string | FX tooltip | Currency pair used for the exchange rate. | 3. Frankfurt, APIFX fetch store and database. | Because `_fetch_exchange_rates` always requests `from=EUR`, `_save_rates_sync` records each term currency under `fx_rates.currency`, letting the serializer label the stored rate as `EUR/{tx.currency_code}` once the metadata is forwarded with the snapshot payload. |
| `purchase_fx.as_of` | ISO 8601 datetime string | FX tooltip “Stand” line | Timestamp associated with `purchase_fx.rate`. | 3. Frankfurt, APIFX fetch store and database. | `ensure_exchange_rates_for_dates_sync` iterates every transaction timestamp, formats it via `dt.strftime("%Y-%m-%d")`, and `_save_rates_sync` keeps that string as the `fx_rates.date` primary key, so wiring the saved metadata into the snapshot will surface the persisted rate date. |
| `data_source` | enum (`live`, `cache`, `historic`) | Cached data notice | Indicates whether the snapshot originates from live or cached data. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `get_security_snapshot` and `_serialise_security_snapshot` currently emit only pricing, aggregation, and performance keys, leaving `data_source` unset, so we still need follow-up logic to tag snapshots as live/cache/historic before sending them.【F:custom_components/pp_reader/data/db_access.py†L654-L667】【F:custom_components/pp_reader/data/websocket.py†L240-L292】 |
| `last_transaction_at` | ISO 8601 datetime string (nullable) | Meta section optional row | Timestamp for the most recent trade involving the security. | 4. Calculate and stored inside the database. | The `transactions` table already stores each trade’s ISO `date` for later aggregation【F:custom_components/pp_reader/data/db_schema.py†L126-L148】, but `get_security_snapshot` still returns a payload without `last_transaction_at`, so we need a follow-up to compute and persist the latest transaction timestamp before emitting the snapshot.【F:custom_components/pp_reader/data/db_access.py†L643-L665】 |

## Security history (`pp_reader/get_security_history` command, `security_history` push)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `security_id` | string (UUID) | History chart container | Identifies which security the series belongs to. | 1. passed from portfolio file and stored in database | Security UUIDs arrive via `PSecurity.uuid`, `_sync_securities` stores them in `securities.uuid`, and the same key is used when persisting `historical_prices.security_uuid` for history queries. |
| `range` | string (`1M`, `3M`, `1Y`, `5Y`, `ALL`, etc.) | Range selector dataset | Confirms which pre-computed window the backend returned. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `ws_get_security_history` already receives `start_date`/`end_date` parameters and echoes them back in the response, so we just need to translate those epoch-day bounds into the canonical range tokens before returning the payload.【F:custom_components/pp_reader/data/websocket.py†L842-L880】【F:tests/test_ws_security_history.py†L331-L467】 |
| `series_source` | enum (`portfolio_performance`, `market_data`) | Chart legend | States where the price series originated. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | Portfolio imports write every `security.prices` row into `historical_prices` without tagging the origin, so once the Yahoo history ingest lands we must persist a source flag (e.g. new column or join table) and let the history serializer map it to `portfolio_performance` vs `market_data` for the legend.【F:custom_components/pp_reader/data/db_schema.py†L57-L73】【F:custom_components/pp_reader/data/sync_from_pclient.py†L1090-L1144】 |
| `prices` | array of price points ordered by date | History chart | Time-series data for plotting. | 2. Yahoo query life fetch store in database. | Yahoo’s `history_1y_1d` sample lists the daily OHLC rows we need, but only `sync_from_pclient` currently persists Portfolio Performance `security.prices` into `historical_prices`, so we still owe a Yahoo history ingest to write those series. |
| `prices[].date` | ISO 8601 date string | Chart axis | Daily timestamp of the price point. | 2. Yahoo query life fetch store in database. | Sample history records ship ISO datestamps, yet `iter_security_close_prices` still reads integer days inserted by the portfolio importer, so the Yahoo pipeline must parse and store these dates before the endpoint can serve them. |
| `prices[].close_native` | number | Chart series | Closing price in the security currency. | 2. Yahoo query life fetch store in database. | Yahoo exposes `close` values alongside each date, but the current importer only copies proto closes into `historical_prices.close`, leaving a follow-up to map the Yahoo field into that column. |
| `prices[].close_eur` | number (optional) | EUR overlay & tooltips | Closing price converted to EUR when supplied. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | The history handler already streams native closes from `iter_security_close_prices`, so we need to extend it to call `normalize_price_to_eur_sync` (same helper used for snapshot `last_close_eur`) per row and emit the rounded EUR value alongside the native series.【F:custom_components/pp_reader/data/websocket.py†L811-L880】【F:custom_components/pp_reader/util/currency.py†L114-L176】【F:custom_components/pp_reader/data/db_access.py†L606-L665】【F:tests/test_db_access.py†L893-L939】 |

## Live update envelope (`panels_updated` bus)

| Field | Format | Used in | Description | Data source back end | Source logic confirmed |
| --- | --- | --- | --- | --- | --- |
| `data_type` | enum (`dashboard_summary`, `accounts`, `portfolio_values`, `portfolio_positions`, `last_file_update`, `security_snapshot`, `security_history`) | `src/dashboard.ts` event handler | Discriminator instructing the dashboard which handler should process the payload. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_push_update` injects the `data_type` argument verbatim into each event payload, and its callers pass the canonical literals (`"accounts"`, `"portfolio_values"`, `"portfolio_positions"`, etc.), so the frontend receives the correct discriminator for every bus message.【F:custom_components/pp_reader/data/event_push.py†L214-L229】【F:custom_components/pp_reader/data/sync_from_pclient.py†L1424-L1562】【F:custom_components/pp_reader/prices/price_service.py†L1078-L1133】 |
| `payload` | object matching the schemas above | Delegated modules | Dataset delivered to the relevant handler without additional guards. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_compact_event_data` only removes redundant keys before `_push_update` nests the structure under `data`, so the handlers receive the same DB-backed payload objects that the importer or price service fetched prior to emission.【F:custom_components/pp_reader/data/event_push.py†L202-L229】【F:custom_components/pp_reader/data/sync_from_pclient.py†L1462-L1562】【F:custom_components/pp_reader/prices/price_service.py†L1078-L1133】 |
| `synced_at` | ISO 8601 datetime string (optional) | Debug overlay / logs | Timestamp indicating when the backend emitted the event. | 6. Calculate it from database values in a function or method and hand it over directly to the front end. | `_push_update` currently emits only `domain`, `entry_id`, `data_type`, and `data`, so we still need to add a timestamp (for example `dt_util.utcnow().isoformat()`) before the frontend can display `synced_at`.【F:custom_components/pp_reader/data/event_push.py†L224-L229】 |

