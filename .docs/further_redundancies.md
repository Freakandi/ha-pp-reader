# Further Redundancies Identified

| Legacy item | Still referenced in | Replacement/helper to adopt |
| --- | --- | --- |
| Manual cent-to-euro conversion via `saldo / 100.0` | `calculate_account_balance` still divides the accumulated saldo by 100 before returning the balance, bypassing the shared helper that enforces consistent rounding.【F:custom_components/pp_reader/logic/accounting.py†L67-L72】 | Use `cent_to_eur(...)` from the currency utility to normalise cents and benefit from centralised rounding rules.【F:custom_components/pp_reader/util/currency.py†L34-L50】 |
| Transaction normalisation divides by 100 throughout `_normalize_transaction_amounts`/`_resolve_native_amount` | Security transaction preparation repeatedly casts integers and divides by 100 for gross amounts, account/native legs, and aggregates instead of delegating to the new helper layer.【F:custom_components/pp_reader/logic/securities.py†L98-L125】【F:custom_components/pp_reader/logic/securities.py†L340-L405】 | Replace the manual divisions with `cent_to_eur(...)`/`round_currency(...)` so transaction math follows the unified currency pipeline introduced in the utility module.【F:custom_components/pp_reader/util/currency.py†L34-L69】 |
| `_normalize_amount` helper performs its own cent handling | The coordinator’s private normaliser accepts ints and divides by 100 or casts floats directly, recreating logic that now lives in the currency helpers.【F:custom_components/pp_reader/data/coordinator.py†L77-L92】 | Swap the body for `cent_to_eur` (and reuse `round_currency` for floats) to eliminate duplicated conversion code and keep coordinator values aligned with backend rounding defaults.【F:custom_components/pp_reader/util/currency.py†L34-L69】 |
| Account sync divides raw balances by 100 before publishing events | `_emit_accounts_update` converts database balances with `/ 100.0` and rounds locally even though the websocket layer already exposes central helpers for these conversions.【F:custom_components/pp_reader/data/sync_from_pclient.py†L1159-L1182】 | Use `cent_to_eur`/`round_currency` when preparing `orig_balance` and `balance` so the sync path stays consistent with the rest of the backend currency stack.【F:custom_components/pp_reader/util/currency.py†L34-L69】 |
| Frontend fallback recomputes `purchase_value_cents` with `Math.round(... * 100)` | `deriveAggregation` still multiplies EUR totals by 100 and rounds when `purchase_value_cents` is missing, duplicating logic that the backend aggregation now provides.【F:src/data/updateConfigsWS.ts†L90-L103】 | Prefer consuming the backend’s `purchase_value_cents`/`purchase_value_eur` from the holdings aggregation and, if fallback is still needed, route it through `roundCurrency` (or a helper built on it) instead of bespoke math.【F:custom_components/pp_reader/data/aggregations.py†L149-L200】【F:src/utils/currency.ts†L87-L116】 |
| Websocket position normalisation rounds currency fields with Python’s built-in `round` | The websocket payload builder still calls `round(...)` for purchase value, gains, holdings and current value even though `round_currency` is imported for that module.【F:custom_components/pp_reader/data/websocket.py†L308-L347】 | Replace the direct `round` calls with `round_currency` so websocket payloads share the same rounding semantics as the rest of the backend helpers.【F:custom_components/pp_reader/util/currency.py†L53-L69】 |

